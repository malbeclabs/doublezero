// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.6
// source: intf.proto

package EosSdkRpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// IntfMgrServiceClient is the client API for IntfMgrService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IntfMgrServiceClient interface {
	// *
	// Subscription to monitor changes on interface properties or status. This request
	// stays active until it is cancelled from client side or the server is shut down.
	// Making this request with all = false and no intf_id has no effect.
	//
	// EosSdk reference: eos::intf_handler (class)
	Watch(ctx context.Context, in *WatchIntfRequest, opts ...grpc.CallOption) (IntfMgrService_WatchClient, error)
	// *
	// Enumerates the interfaces.
	//
	// EosSdk reference: eos::intf_mgr::intf_iter
	Intfs(ctx context.Context, in *IntfsRequest, opts ...grpc.CallOption) (IntfMgrService_IntfsClient, error)
	// *
	// Queries whether an interface exists or not.
	//
	// EosSdk reference: eos::intf_mgr::exists
	Exists(ctx context.Context, in *IntfExistsRequest, opts ...grpc.CallOption) (*IntfExistsResponse, error)
	// *
	// Queries the kernel device for a particular interface.
	//
	// EosSdk reference: eos::intf_mgr::kernel_intf_name
	KernelIntfName(ctx context.Context, in *KernelIntfNameRequest, opts ...grpc.CallOption) (*KernelIntfNameResponse, error)
	// *
	// Queries EOS interface name for a particular kernel device.
	//
	// EosSdk reference: eos::intf_mgr::eos_intf_name
	EosIntfName(ctx context.Context, in *EosIntfNameRequest, opts ...grpc.CallOption) (*EosIntfNameResponse, error)
	// *
	// Queries if an interface is configured to be enabled.
	//
	// EosSdk reference: eos::intf_mgr::admin_enabled
	AdminEnabled(ctx context.Context, in *AdminEnabledRequest, opts ...grpc.CallOption) (*AdminEnabledResponse, error)
	// *
	// Changes the enabled status of an interface.
	//
	// EosSdk reference: eos::intf_mgr::admin_enabled_is
	AdminEnabledIs(ctx context.Context, in *AdminEnabledIsRequest, opts ...grpc.CallOption) (*AdminEnabledIsResponse, error)
	// *
	// Changes the enabled status of multiple interfaces.
	//
	// EosSdk reference: eos::intf_mgr::admin_enabled_is
	BulkAdminEnabledIs(ctx context.Context, in *BulkAdminEnabledIsRequest, opts ...grpc.CallOption) (*BulkAdminEnabledIsResponse, error)
	// *
	// Queries the description of an interface
	//
	// EosSdk reference: eos::intf_mgr::description
	Description(ctx context.Context, in *DescriptionRequest, opts ...grpc.CallOption) (*DescriptionResponse, error)
	// *
	// Changes the description of an interface
	//
	// EosSdk reference: eos::intf_mgr::description_is
	DescriptionIs(ctx context.Context, in *DescriptionIsRequest, opts ...grpc.CallOption) (*DescriptionIsResponse, error)
	// *
	// Changes descriptions of multiple interfaces
	//
	// EosSdk reference: eos::intf_mgr::oper_description_is
	BulkDescriptionIs(ctx context.Context, in *BulkDescriptionIsRequest, opts ...grpc.CallOption) (*BulkDescriptionIsResponse, error)
	// *
	// Queries the current operational status of the given interface.
	//
	// EosSdk reference: eos::intf_mgr::oper_status
	OperStatus(ctx context.Context, in *OperStatusRequest, opts ...grpc.CallOption) (*OperStatusResponse, error)
}

type intfMgrServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIntfMgrServiceClient(cc grpc.ClientConnInterface) IntfMgrServiceClient {
	return &intfMgrServiceClient{cc}
}

func (c *intfMgrServiceClient) Watch(ctx context.Context, in *WatchIntfRequest, opts ...grpc.CallOption) (IntfMgrService_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &IntfMgrService_ServiceDesc.Streams[0], "/eos.remote.IntfMgrService/watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &intfMgrServiceWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IntfMgrService_WatchClient interface {
	Recv() (*WatchIntfResponse, error)
	grpc.ClientStream
}

type intfMgrServiceWatchClient struct {
	grpc.ClientStream
}

func (x *intfMgrServiceWatchClient) Recv() (*WatchIntfResponse, error) {
	m := new(WatchIntfResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *intfMgrServiceClient) Intfs(ctx context.Context, in *IntfsRequest, opts ...grpc.CallOption) (IntfMgrService_IntfsClient, error) {
	stream, err := c.cc.NewStream(ctx, &IntfMgrService_ServiceDesc.Streams[1], "/eos.remote.IntfMgrService/intfs", opts...)
	if err != nil {
		return nil, err
	}
	x := &intfMgrServiceIntfsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IntfMgrService_IntfsClient interface {
	Recv() (*IntfsResponse, error)
	grpc.ClientStream
}

type intfMgrServiceIntfsClient struct {
	grpc.ClientStream
}

func (x *intfMgrServiceIntfsClient) Recv() (*IntfsResponse, error) {
	m := new(IntfsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *intfMgrServiceClient) Exists(ctx context.Context, in *IntfExistsRequest, opts ...grpc.CallOption) (*IntfExistsResponse, error) {
	out := new(IntfExistsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IntfMgrService/exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intfMgrServiceClient) KernelIntfName(ctx context.Context, in *KernelIntfNameRequest, opts ...grpc.CallOption) (*KernelIntfNameResponse, error) {
	out := new(KernelIntfNameResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IntfMgrService/kernel_intf_name", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intfMgrServiceClient) EosIntfName(ctx context.Context, in *EosIntfNameRequest, opts ...grpc.CallOption) (*EosIntfNameResponse, error) {
	out := new(EosIntfNameResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IntfMgrService/eos_intf_name", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intfMgrServiceClient) AdminEnabled(ctx context.Context, in *AdminEnabledRequest, opts ...grpc.CallOption) (*AdminEnabledResponse, error) {
	out := new(AdminEnabledResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IntfMgrService/admin_enabled", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intfMgrServiceClient) AdminEnabledIs(ctx context.Context, in *AdminEnabledIsRequest, opts ...grpc.CallOption) (*AdminEnabledIsResponse, error) {
	out := new(AdminEnabledIsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IntfMgrService/admin_enabled_is", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intfMgrServiceClient) BulkAdminEnabledIs(ctx context.Context, in *BulkAdminEnabledIsRequest, opts ...grpc.CallOption) (*BulkAdminEnabledIsResponse, error) {
	out := new(BulkAdminEnabledIsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IntfMgrService/bulk_admin_enabled_is", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intfMgrServiceClient) Description(ctx context.Context, in *DescriptionRequest, opts ...grpc.CallOption) (*DescriptionResponse, error) {
	out := new(DescriptionResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IntfMgrService/description", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intfMgrServiceClient) DescriptionIs(ctx context.Context, in *DescriptionIsRequest, opts ...grpc.CallOption) (*DescriptionIsResponse, error) {
	out := new(DescriptionIsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IntfMgrService/description_is", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intfMgrServiceClient) BulkDescriptionIs(ctx context.Context, in *BulkDescriptionIsRequest, opts ...grpc.CallOption) (*BulkDescriptionIsResponse, error) {
	out := new(BulkDescriptionIsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IntfMgrService/bulk_description_is", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intfMgrServiceClient) OperStatus(ctx context.Context, in *OperStatusRequest, opts ...grpc.CallOption) (*OperStatusResponse, error) {
	out := new(OperStatusResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IntfMgrService/oper_status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IntfMgrServiceServer is the server API for IntfMgrService service.
// All implementations should embed UnimplementedIntfMgrServiceServer
// for forward compatibility
type IntfMgrServiceServer interface {
	// *
	// Subscription to monitor changes on interface properties or status. This request
	// stays active until it is cancelled from client side or the server is shut down.
	// Making this request with all = false and no intf_id has no effect.
	//
	// EosSdk reference: eos::intf_handler (class)
	Watch(*WatchIntfRequest, IntfMgrService_WatchServer) error
	// *
	// Enumerates the interfaces.
	//
	// EosSdk reference: eos::intf_mgr::intf_iter
	Intfs(*IntfsRequest, IntfMgrService_IntfsServer) error
	// *
	// Queries whether an interface exists or not.
	//
	// EosSdk reference: eos::intf_mgr::exists
	Exists(context.Context, *IntfExistsRequest) (*IntfExistsResponse, error)
	// *
	// Queries the kernel device for a particular interface.
	//
	// EosSdk reference: eos::intf_mgr::kernel_intf_name
	KernelIntfName(context.Context, *KernelIntfNameRequest) (*KernelIntfNameResponse, error)
	// *
	// Queries EOS interface name for a particular kernel device.
	//
	// EosSdk reference: eos::intf_mgr::eos_intf_name
	EosIntfName(context.Context, *EosIntfNameRequest) (*EosIntfNameResponse, error)
	// *
	// Queries if an interface is configured to be enabled.
	//
	// EosSdk reference: eos::intf_mgr::admin_enabled
	AdminEnabled(context.Context, *AdminEnabledRequest) (*AdminEnabledResponse, error)
	// *
	// Changes the enabled status of an interface.
	//
	// EosSdk reference: eos::intf_mgr::admin_enabled_is
	AdminEnabledIs(context.Context, *AdminEnabledIsRequest) (*AdminEnabledIsResponse, error)
	// *
	// Changes the enabled status of multiple interfaces.
	//
	// EosSdk reference: eos::intf_mgr::admin_enabled_is
	BulkAdminEnabledIs(context.Context, *BulkAdminEnabledIsRequest) (*BulkAdminEnabledIsResponse, error)
	// *
	// Queries the description of an interface
	//
	// EosSdk reference: eos::intf_mgr::description
	Description(context.Context, *DescriptionRequest) (*DescriptionResponse, error)
	// *
	// Changes the description of an interface
	//
	// EosSdk reference: eos::intf_mgr::description_is
	DescriptionIs(context.Context, *DescriptionIsRequest) (*DescriptionIsResponse, error)
	// *
	// Changes descriptions of multiple interfaces
	//
	// EosSdk reference: eos::intf_mgr::oper_description_is
	BulkDescriptionIs(context.Context, *BulkDescriptionIsRequest) (*BulkDescriptionIsResponse, error)
	// *
	// Queries the current operational status of the given interface.
	//
	// EosSdk reference: eos::intf_mgr::oper_status
	OperStatus(context.Context, *OperStatusRequest) (*OperStatusResponse, error)
}

// UnimplementedIntfMgrServiceServer should be embedded to have forward compatible implementations.
type UnimplementedIntfMgrServiceServer struct {
}

func (UnimplementedIntfMgrServiceServer) Watch(*WatchIntfRequest, IntfMgrService_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedIntfMgrServiceServer) Intfs(*IntfsRequest, IntfMgrService_IntfsServer) error {
	return status.Errorf(codes.Unimplemented, "method Intfs not implemented")
}
func (UnimplementedIntfMgrServiceServer) Exists(context.Context, *IntfExistsRequest) (*IntfExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exists not implemented")
}
func (UnimplementedIntfMgrServiceServer) KernelIntfName(context.Context, *KernelIntfNameRequest) (*KernelIntfNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KernelIntfName not implemented")
}
func (UnimplementedIntfMgrServiceServer) EosIntfName(context.Context, *EosIntfNameRequest) (*EosIntfNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EosIntfName not implemented")
}
func (UnimplementedIntfMgrServiceServer) AdminEnabled(context.Context, *AdminEnabledRequest) (*AdminEnabledResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminEnabled not implemented")
}
func (UnimplementedIntfMgrServiceServer) AdminEnabledIs(context.Context, *AdminEnabledIsRequest) (*AdminEnabledIsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AdminEnabledIs not implemented")
}
func (UnimplementedIntfMgrServiceServer) BulkAdminEnabledIs(context.Context, *BulkAdminEnabledIsRequest) (*BulkAdminEnabledIsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkAdminEnabledIs not implemented")
}
func (UnimplementedIntfMgrServiceServer) Description(context.Context, *DescriptionRequest) (*DescriptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Description not implemented")
}
func (UnimplementedIntfMgrServiceServer) DescriptionIs(context.Context, *DescriptionIsRequest) (*DescriptionIsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescriptionIs not implemented")
}
func (UnimplementedIntfMgrServiceServer) BulkDescriptionIs(context.Context, *BulkDescriptionIsRequest) (*BulkDescriptionIsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkDescriptionIs not implemented")
}
func (UnimplementedIntfMgrServiceServer) OperStatus(context.Context, *OperStatusRequest) (*OperStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperStatus not implemented")
}

// UnsafeIntfMgrServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IntfMgrServiceServer will
// result in compilation errors.
type UnsafeIntfMgrServiceServer interface {
	mustEmbedUnimplementedIntfMgrServiceServer()
}

func RegisterIntfMgrServiceServer(s grpc.ServiceRegistrar, srv IntfMgrServiceServer) {
	s.RegisterService(&IntfMgrService_ServiceDesc, srv)
}

func _IntfMgrService_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchIntfRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IntfMgrServiceServer).Watch(m, &intfMgrServiceWatchServer{stream})
}

type IntfMgrService_WatchServer interface {
	Send(*WatchIntfResponse) error
	grpc.ServerStream
}

type intfMgrServiceWatchServer struct {
	grpc.ServerStream
}

func (x *intfMgrServiceWatchServer) Send(m *WatchIntfResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _IntfMgrService_Intfs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IntfsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IntfMgrServiceServer).Intfs(m, &intfMgrServiceIntfsServer{stream})
}

type IntfMgrService_IntfsServer interface {
	Send(*IntfsResponse) error
	grpc.ServerStream
}

type intfMgrServiceIntfsServer struct {
	grpc.ServerStream
}

func (x *intfMgrServiceIntfsServer) Send(m *IntfsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _IntfMgrService_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntfExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntfMgrServiceServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IntfMgrService/exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntfMgrServiceServer).Exists(ctx, req.(*IntfExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntfMgrService_KernelIntfName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KernelIntfNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntfMgrServiceServer).KernelIntfName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IntfMgrService/kernel_intf_name",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntfMgrServiceServer).KernelIntfName(ctx, req.(*KernelIntfNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntfMgrService_EosIntfName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EosIntfNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntfMgrServiceServer).EosIntfName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IntfMgrService/eos_intf_name",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntfMgrServiceServer).EosIntfName(ctx, req.(*EosIntfNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntfMgrService_AdminEnabled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminEnabledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntfMgrServiceServer).AdminEnabled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IntfMgrService/admin_enabled",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntfMgrServiceServer).AdminEnabled(ctx, req.(*AdminEnabledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntfMgrService_AdminEnabledIs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AdminEnabledIsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntfMgrServiceServer).AdminEnabledIs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IntfMgrService/admin_enabled_is",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntfMgrServiceServer).AdminEnabledIs(ctx, req.(*AdminEnabledIsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntfMgrService_BulkAdminEnabledIs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkAdminEnabledIsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntfMgrServiceServer).BulkAdminEnabledIs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IntfMgrService/bulk_admin_enabled_is",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntfMgrServiceServer).BulkAdminEnabledIs(ctx, req.(*BulkAdminEnabledIsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntfMgrService_Description_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntfMgrServiceServer).Description(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IntfMgrService/description",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntfMgrServiceServer).Description(ctx, req.(*DescriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntfMgrService_DescriptionIs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescriptionIsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntfMgrServiceServer).DescriptionIs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IntfMgrService/description_is",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntfMgrServiceServer).DescriptionIs(ctx, req.(*DescriptionIsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntfMgrService_BulkDescriptionIs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkDescriptionIsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntfMgrServiceServer).BulkDescriptionIs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IntfMgrService/bulk_description_is",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntfMgrServiceServer).BulkDescriptionIs(ctx, req.(*BulkDescriptionIsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntfMgrService_OperStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntfMgrServiceServer).OperStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IntfMgrService/oper_status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntfMgrServiceServer).OperStatus(ctx, req.(*OperStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IntfMgrService_ServiceDesc is the grpc.ServiceDesc for IntfMgrService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IntfMgrService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eos.remote.IntfMgrService",
	HandlerType: (*IntfMgrServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "exists",
			Handler:    _IntfMgrService_Exists_Handler,
		},
		{
			MethodName: "kernel_intf_name",
			Handler:    _IntfMgrService_KernelIntfName_Handler,
		},
		{
			MethodName: "eos_intf_name",
			Handler:    _IntfMgrService_EosIntfName_Handler,
		},
		{
			MethodName: "admin_enabled",
			Handler:    _IntfMgrService_AdminEnabled_Handler,
		},
		{
			MethodName: "admin_enabled_is",
			Handler:    _IntfMgrService_AdminEnabledIs_Handler,
		},
		{
			MethodName: "bulk_admin_enabled_is",
			Handler:    _IntfMgrService_BulkAdminEnabledIs_Handler,
		},
		{
			MethodName: "description",
			Handler:    _IntfMgrService_Description_Handler,
		},
		{
			MethodName: "description_is",
			Handler:    _IntfMgrService_DescriptionIs_Handler,
		},
		{
			MethodName: "bulk_description_is",
			Handler:    _IntfMgrService_BulkDescriptionIs_Handler,
		},
		{
			MethodName: "oper_status",
			Handler:    _IntfMgrService_OperStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "watch",
			Handler:       _IntfMgrService_Watch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "intfs",
			Handler:       _IntfMgrService_Intfs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "intf.proto",
}

// IntfCounterMgrServiceClient is the client API for IntfCounterMgrService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IntfCounterMgrServiceClient interface {
	// *
	// Queries the given interface for the current counters.
	//
	// EosSdk reference: eos::intf_counter_mgr::counters
	IntfCounters(ctx context.Context, in *IntfCountersRequest, opts ...grpc.CallOption) (*IntfCountersResponse, error)
	// *
	// Queries the given interface for the current traffic rates.
	//
	// EosSdk reference: eos::intf_counter_mgr::traffic_rates
	IntfTrafficRates(ctx context.Context, in *IntfTrafficRatesRequest, opts ...grpc.CallOption) (*IntfTrafficRatesResponse, error)
	// Streams traffic rate updates
	IntfTrafficRatesStream(ctx context.Context, in *IntfTrafficRatesStreamRequest, opts ...grpc.CallOption) (IntfCounterMgrService_IntfTrafficRatesStreamClient, error)
}

type intfCounterMgrServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIntfCounterMgrServiceClient(cc grpc.ClientConnInterface) IntfCounterMgrServiceClient {
	return &intfCounterMgrServiceClient{cc}
}

func (c *intfCounterMgrServiceClient) IntfCounters(ctx context.Context, in *IntfCountersRequest, opts ...grpc.CallOption) (*IntfCountersResponse, error) {
	out := new(IntfCountersResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IntfCounterMgrService/intf_counters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intfCounterMgrServiceClient) IntfTrafficRates(ctx context.Context, in *IntfTrafficRatesRequest, opts ...grpc.CallOption) (*IntfTrafficRatesResponse, error) {
	out := new(IntfTrafficRatesResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IntfCounterMgrService/intf_traffic_rates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *intfCounterMgrServiceClient) IntfTrafficRatesStream(ctx context.Context, in *IntfTrafficRatesStreamRequest, opts ...grpc.CallOption) (IntfCounterMgrService_IntfTrafficRatesStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &IntfCounterMgrService_ServiceDesc.Streams[0], "/eos.remote.IntfCounterMgrService/intf_traffic_rates_stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &intfCounterMgrServiceIntfTrafficRatesStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IntfCounterMgrService_IntfTrafficRatesStreamClient interface {
	Recv() (*IntfTrafficRatesStreamResponse, error)
	grpc.ClientStream
}

type intfCounterMgrServiceIntfTrafficRatesStreamClient struct {
	grpc.ClientStream
}

func (x *intfCounterMgrServiceIntfTrafficRatesStreamClient) Recv() (*IntfTrafficRatesStreamResponse, error) {
	m := new(IntfTrafficRatesStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IntfCounterMgrServiceServer is the server API for IntfCounterMgrService service.
// All implementations should embed UnimplementedIntfCounterMgrServiceServer
// for forward compatibility
type IntfCounterMgrServiceServer interface {
	// *
	// Queries the given interface for the current counters.
	//
	// EosSdk reference: eos::intf_counter_mgr::counters
	IntfCounters(context.Context, *IntfCountersRequest) (*IntfCountersResponse, error)
	// *
	// Queries the given interface for the current traffic rates.
	//
	// EosSdk reference: eos::intf_counter_mgr::traffic_rates
	IntfTrafficRates(context.Context, *IntfTrafficRatesRequest) (*IntfTrafficRatesResponse, error)
	// Streams traffic rate updates
	IntfTrafficRatesStream(*IntfTrafficRatesStreamRequest, IntfCounterMgrService_IntfTrafficRatesStreamServer) error
}

// UnimplementedIntfCounterMgrServiceServer should be embedded to have forward compatible implementations.
type UnimplementedIntfCounterMgrServiceServer struct {
}

func (UnimplementedIntfCounterMgrServiceServer) IntfCounters(context.Context, *IntfCountersRequest) (*IntfCountersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IntfCounters not implemented")
}
func (UnimplementedIntfCounterMgrServiceServer) IntfTrafficRates(context.Context, *IntfTrafficRatesRequest) (*IntfTrafficRatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IntfTrafficRates not implemented")
}
func (UnimplementedIntfCounterMgrServiceServer) IntfTrafficRatesStream(*IntfTrafficRatesStreamRequest, IntfCounterMgrService_IntfTrafficRatesStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method IntfTrafficRatesStream not implemented")
}

// UnsafeIntfCounterMgrServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IntfCounterMgrServiceServer will
// result in compilation errors.
type UnsafeIntfCounterMgrServiceServer interface {
	mustEmbedUnimplementedIntfCounterMgrServiceServer()
}

func RegisterIntfCounterMgrServiceServer(s grpc.ServiceRegistrar, srv IntfCounterMgrServiceServer) {
	s.RegisterService(&IntfCounterMgrService_ServiceDesc, srv)
}

func _IntfCounterMgrService_IntfCounters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntfCountersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntfCounterMgrServiceServer).IntfCounters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IntfCounterMgrService/intf_counters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntfCounterMgrServiceServer).IntfCounters(ctx, req.(*IntfCountersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntfCounterMgrService_IntfTrafficRates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntfTrafficRatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntfCounterMgrServiceServer).IntfTrafficRates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IntfCounterMgrService/intf_traffic_rates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntfCounterMgrServiceServer).IntfTrafficRates(ctx, req.(*IntfTrafficRatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IntfCounterMgrService_IntfTrafficRatesStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IntfTrafficRatesStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IntfCounterMgrServiceServer).IntfTrafficRatesStream(m, &intfCounterMgrServiceIntfTrafficRatesStreamServer{stream})
}

type IntfCounterMgrService_IntfTrafficRatesStreamServer interface {
	Send(*IntfTrafficRatesStreamResponse) error
	grpc.ServerStream
}

type intfCounterMgrServiceIntfTrafficRatesStreamServer struct {
	grpc.ServerStream
}

func (x *intfCounterMgrServiceIntfTrafficRatesStreamServer) Send(m *IntfTrafficRatesStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

// IntfCounterMgrService_ServiceDesc is the grpc.ServiceDesc for IntfCounterMgrService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IntfCounterMgrService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eos.remote.IntfCounterMgrService",
	HandlerType: (*IntfCounterMgrServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "intf_counters",
			Handler:    _IntfCounterMgrService_IntfCounters_Handler,
		},
		{
			MethodName: "intf_traffic_rates",
			Handler:    _IntfCounterMgrService_IntfTrafficRates_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "intf_traffic_rates_stream",
			Handler:       _IntfCounterMgrService_IntfTrafficRatesStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "intf.proto",
}
