// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.6
// source: nexthop_group.proto

package EosSdkRpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NexthopGroupMgrServiceClient is the client API for NexthopGroupMgrService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NexthopGroupMgrServiceClient interface {
	// *
	// Subscription to monitor changes on nexthop groups. This request
	// stays active until the client cancels or the server shuts down.
	// When all = false and no name is specified, this request has no effect.
	//
	// EosSdk reference: eos::nexthop_group_handler (class)
	Watch(ctx context.Context, in *WatchNexthopGroupRequest, opts ...grpc.CallOption) (NexthopGroupMgrService_WatchClient, error)
	// *
	// Initiates a resync process. Starts a blank configuration to be applied
	// once resync_complete is called.
	//
	// EosSdk reference: eos::nexthop_group_mgr::resync_init
	ResyncInit(ctx context.Context, in *ResyncNexthopGroupInitRequest, opts ...grpc.CallOption) (*ResyncNexthopGroupInitResponse, error)
	// *
	// Deletes current configuration and applies all changes since resync_init has
	// been called last.
	//
	// EosSdk reference: eos::nexthop_group_mgr::resync_complete
	ResyncComplete(ctx context.Context, in *ResyncNexthopGroupCompleteRequest, opts ...grpc.CallOption) (*ResyncNexthopGroupCompleteResponse, error)
	// *
	// Returns a list of all configured nexthop groups.
	//
	// EosSdk reference: eos::nexthop_group_mgr::nexthop_group_iter
	NexthopGroups(ctx context.Context, in *NexthopGroupsRequest, opts ...grpc.CallOption) (NexthopGroupMgrService_NexthopGroupsClient, error)
	// *
	// Returns a list of all programmed nexthop groups.
	//
	// EosSdk reference: eos::nexthop_group_mgr::programmed_nexthop_group_iter
	ProgrammedNexthopGroups(ctx context.Context, in *ProgrammedNexthopGroupsRequest, opts ...grpc.CallOption) (NexthopGroupMgrService_ProgrammedNexthopGroupsClient, error)
	// *
	// Returns the configured nexthop group specified by name, if exists.
	//
	// EosSdk reference: eos::nexthop_group_mgr::nexthop_group
	NexthopGroup(ctx context.Context, in *NexthopGroupRequest, opts ...grpc.CallOption) (*NexthopGroupResponse, error)
	// *
	// Returns the counter corresponding to the given nexthop group name and entry.
	//
	// EosSdk reference: eos::nexthop_group_mgr::counter
	Counter(ctx context.Context, in *CounterRequest, opts ...grpc.CallOption) (*CounterResponse, error)
	// *
	// Returns the counter corresponding to the given nexthop group name or
	// a set of nexthop groups that have names matching the regex pattern or
	// all nexthop groups in the system when all=true.
	// When all = false and no name or regex is specified, this request has no effect.
	// When multiple fields are set, the last set field takes precedence.
	//
	// EosSdk reference: eos::nexthop_group_handler (class)
	NhgCounters(ctx context.Context, in *NexthopGroupCountersRequest, opts ...grpc.CallOption) (NexthopGroupMgrService_NhgCountersClient, error)
	// *
	// Queries if the nexthop group with given name exists.
	//
	// EosSdk reference: eos::nexthop_group_mgr::exists
	Exists(ctx context.Context, in *NexthopGroupExistsRequest, opts ...grpc.CallOption) (*NexthopGroupExistsResponse, error)
	// *
	// Queries whether a nexthop group is active
	//
	// EosSdk reference: eos::nexthop_group_mgr::active
	Active(ctx context.Context, in *NexthopGroupActiveRequest, opts ...grpc.CallOption) (*NexthopGroupActiveResponse, error)
	// *
	// Creates or updates a nexthop group and returns its version ID.
	//
	// EosSdk reference: eos::nexthop_group_mgr::nexthop_group_set
	NexthopGroupSet(ctx context.Context, in *NexthopGroupSetRequest, opts ...grpc.CallOption) (*NexthopGroupSetResponse, error)
	// *
	// Creates or updates multiple nexthops groups in a single call and returns their version IDs.
	//
	// EosSdk reference: eos::nexthop_group_mgr::nexthop_group_set
	BulkNexthopGroupSet(ctx context.Context, in *BulkNexthopGroupSetRequest, opts ...grpc.CallOption) (*BulkNexthopGroupSetResponse, error)
	// *
	// Deletes a nexthop group.
	//
	// EosSdk reference: eos::nexthop_group_mgr::nexthop_group_del
	NexthopGroupDel(ctx context.Context, in *NexthopGroupDelRequest, opts ...grpc.CallOption) (*NexthopGroupDelResponse, error)
	// *
	// Deletes multiple nexthop groups in a single call.
	//
	// EosSdk reference: eos::nexthop_group_mgr::nexthop_group_del
	BulkNexthopGroupDel(ctx context.Context, in *BulkNexthopGroupDelRequest, opts ...grpc.CallOption) (*BulkNexthopGroupDelResponse, error)
	// *
	// Queries a programmed nexthop group by name.
	//
	// EosSdk reference: eos::nexthop_group_mgr::programmed_nexthop_group
	ProgrammedNexthopGroup(ctx context.Context, in *ProgrammedNexthopGroupRequest, opts ...grpc.CallOption) (*ProgrammedNexthopGroupResponse, error)
}

type nexthopGroupMgrServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNexthopGroupMgrServiceClient(cc grpc.ClientConnInterface) NexthopGroupMgrServiceClient {
	return &nexthopGroupMgrServiceClient{cc}
}

func (c *nexthopGroupMgrServiceClient) Watch(ctx context.Context, in *WatchNexthopGroupRequest, opts ...grpc.CallOption) (NexthopGroupMgrService_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &NexthopGroupMgrService_ServiceDesc.Streams[0], "/eos.remote.NexthopGroupMgrService/watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &nexthopGroupMgrServiceWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NexthopGroupMgrService_WatchClient interface {
	Recv() (*WatchNexthopGroupResponse, error)
	grpc.ClientStream
}

type nexthopGroupMgrServiceWatchClient struct {
	grpc.ClientStream
}

func (x *nexthopGroupMgrServiceWatchClient) Recv() (*WatchNexthopGroupResponse, error) {
	m := new(WatchNexthopGroupResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nexthopGroupMgrServiceClient) ResyncInit(ctx context.Context, in *ResyncNexthopGroupInitRequest, opts ...grpc.CallOption) (*ResyncNexthopGroupInitResponse, error) {
	out := new(ResyncNexthopGroupInitResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.NexthopGroupMgrService/resync_init", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nexthopGroupMgrServiceClient) ResyncComplete(ctx context.Context, in *ResyncNexthopGroupCompleteRequest, opts ...grpc.CallOption) (*ResyncNexthopGroupCompleteResponse, error) {
	out := new(ResyncNexthopGroupCompleteResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.NexthopGroupMgrService/resync_complete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nexthopGroupMgrServiceClient) NexthopGroups(ctx context.Context, in *NexthopGroupsRequest, opts ...grpc.CallOption) (NexthopGroupMgrService_NexthopGroupsClient, error) {
	stream, err := c.cc.NewStream(ctx, &NexthopGroupMgrService_ServiceDesc.Streams[1], "/eos.remote.NexthopGroupMgrService/nexthop_groups", opts...)
	if err != nil {
		return nil, err
	}
	x := &nexthopGroupMgrServiceNexthopGroupsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NexthopGroupMgrService_NexthopGroupsClient interface {
	Recv() (*NexthopGroupsResponse, error)
	grpc.ClientStream
}

type nexthopGroupMgrServiceNexthopGroupsClient struct {
	grpc.ClientStream
}

func (x *nexthopGroupMgrServiceNexthopGroupsClient) Recv() (*NexthopGroupsResponse, error) {
	m := new(NexthopGroupsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nexthopGroupMgrServiceClient) ProgrammedNexthopGroups(ctx context.Context, in *ProgrammedNexthopGroupsRequest, opts ...grpc.CallOption) (NexthopGroupMgrService_ProgrammedNexthopGroupsClient, error) {
	stream, err := c.cc.NewStream(ctx, &NexthopGroupMgrService_ServiceDesc.Streams[2], "/eos.remote.NexthopGroupMgrService/programmed_nexthop_groups", opts...)
	if err != nil {
		return nil, err
	}
	x := &nexthopGroupMgrServiceProgrammedNexthopGroupsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NexthopGroupMgrService_ProgrammedNexthopGroupsClient interface {
	Recv() (*ProgrammedNexthopGroupsResponse, error)
	grpc.ClientStream
}

type nexthopGroupMgrServiceProgrammedNexthopGroupsClient struct {
	grpc.ClientStream
}

func (x *nexthopGroupMgrServiceProgrammedNexthopGroupsClient) Recv() (*ProgrammedNexthopGroupsResponse, error) {
	m := new(ProgrammedNexthopGroupsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nexthopGroupMgrServiceClient) NexthopGroup(ctx context.Context, in *NexthopGroupRequest, opts ...grpc.CallOption) (*NexthopGroupResponse, error) {
	out := new(NexthopGroupResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.NexthopGroupMgrService/nexthop_group", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nexthopGroupMgrServiceClient) Counter(ctx context.Context, in *CounterRequest, opts ...grpc.CallOption) (*CounterResponse, error) {
	out := new(CounterResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.NexthopGroupMgrService/counter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nexthopGroupMgrServiceClient) NhgCounters(ctx context.Context, in *NexthopGroupCountersRequest, opts ...grpc.CallOption) (NexthopGroupMgrService_NhgCountersClient, error) {
	stream, err := c.cc.NewStream(ctx, &NexthopGroupMgrService_ServiceDesc.Streams[3], "/eos.remote.NexthopGroupMgrService/nhg_counters", opts...)
	if err != nil {
		return nil, err
	}
	x := &nexthopGroupMgrServiceNhgCountersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NexthopGroupMgrService_NhgCountersClient interface {
	Recv() (*NexthopGroupCountersResponse, error)
	grpc.ClientStream
}

type nexthopGroupMgrServiceNhgCountersClient struct {
	grpc.ClientStream
}

func (x *nexthopGroupMgrServiceNhgCountersClient) Recv() (*NexthopGroupCountersResponse, error) {
	m := new(NexthopGroupCountersResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nexthopGroupMgrServiceClient) Exists(ctx context.Context, in *NexthopGroupExistsRequest, opts ...grpc.CallOption) (*NexthopGroupExistsResponse, error) {
	out := new(NexthopGroupExistsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.NexthopGroupMgrService/exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nexthopGroupMgrServiceClient) Active(ctx context.Context, in *NexthopGroupActiveRequest, opts ...grpc.CallOption) (*NexthopGroupActiveResponse, error) {
	out := new(NexthopGroupActiveResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.NexthopGroupMgrService/active", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nexthopGroupMgrServiceClient) NexthopGroupSet(ctx context.Context, in *NexthopGroupSetRequest, opts ...grpc.CallOption) (*NexthopGroupSetResponse, error) {
	out := new(NexthopGroupSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.NexthopGroupMgrService/nexthop_group_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nexthopGroupMgrServiceClient) BulkNexthopGroupSet(ctx context.Context, in *BulkNexthopGroupSetRequest, opts ...grpc.CallOption) (*BulkNexthopGroupSetResponse, error) {
	out := new(BulkNexthopGroupSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.NexthopGroupMgrService/bulk_nexthop_group_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nexthopGroupMgrServiceClient) NexthopGroupDel(ctx context.Context, in *NexthopGroupDelRequest, opts ...grpc.CallOption) (*NexthopGroupDelResponse, error) {
	out := new(NexthopGroupDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.NexthopGroupMgrService/nexthop_group_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nexthopGroupMgrServiceClient) BulkNexthopGroupDel(ctx context.Context, in *BulkNexthopGroupDelRequest, opts ...grpc.CallOption) (*BulkNexthopGroupDelResponse, error) {
	out := new(BulkNexthopGroupDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.NexthopGroupMgrService/bulk_nexthop_group_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nexthopGroupMgrServiceClient) ProgrammedNexthopGroup(ctx context.Context, in *ProgrammedNexthopGroupRequest, opts ...grpc.CallOption) (*ProgrammedNexthopGroupResponse, error) {
	out := new(ProgrammedNexthopGroupResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.NexthopGroupMgrService/programmed_nexthop_group", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NexthopGroupMgrServiceServer is the server API for NexthopGroupMgrService service.
// All implementations should embed UnimplementedNexthopGroupMgrServiceServer
// for forward compatibility
type NexthopGroupMgrServiceServer interface {
	// *
	// Subscription to monitor changes on nexthop groups. This request
	// stays active until the client cancels or the server shuts down.
	// When all = false and no name is specified, this request has no effect.
	//
	// EosSdk reference: eos::nexthop_group_handler (class)
	Watch(*WatchNexthopGroupRequest, NexthopGroupMgrService_WatchServer) error
	// *
	// Initiates a resync process. Starts a blank configuration to be applied
	// once resync_complete is called.
	//
	// EosSdk reference: eos::nexthop_group_mgr::resync_init
	ResyncInit(context.Context, *ResyncNexthopGroupInitRequest) (*ResyncNexthopGroupInitResponse, error)
	// *
	// Deletes current configuration and applies all changes since resync_init has
	// been called last.
	//
	// EosSdk reference: eos::nexthop_group_mgr::resync_complete
	ResyncComplete(context.Context, *ResyncNexthopGroupCompleteRequest) (*ResyncNexthopGroupCompleteResponse, error)
	// *
	// Returns a list of all configured nexthop groups.
	//
	// EosSdk reference: eos::nexthop_group_mgr::nexthop_group_iter
	NexthopGroups(*NexthopGroupsRequest, NexthopGroupMgrService_NexthopGroupsServer) error
	// *
	// Returns a list of all programmed nexthop groups.
	//
	// EosSdk reference: eos::nexthop_group_mgr::programmed_nexthop_group_iter
	ProgrammedNexthopGroups(*ProgrammedNexthopGroupsRequest, NexthopGroupMgrService_ProgrammedNexthopGroupsServer) error
	// *
	// Returns the configured nexthop group specified by name, if exists.
	//
	// EosSdk reference: eos::nexthop_group_mgr::nexthop_group
	NexthopGroup(context.Context, *NexthopGroupRequest) (*NexthopGroupResponse, error)
	// *
	// Returns the counter corresponding to the given nexthop group name and entry.
	//
	// EosSdk reference: eos::nexthop_group_mgr::counter
	Counter(context.Context, *CounterRequest) (*CounterResponse, error)
	// *
	// Returns the counter corresponding to the given nexthop group name or
	// a set of nexthop groups that have names matching the regex pattern or
	// all nexthop groups in the system when all=true.
	// When all = false and no name or regex is specified, this request has no effect.
	// When multiple fields are set, the last set field takes precedence.
	//
	// EosSdk reference: eos::nexthop_group_handler (class)
	NhgCounters(*NexthopGroupCountersRequest, NexthopGroupMgrService_NhgCountersServer) error
	// *
	// Queries if the nexthop group with given name exists.
	//
	// EosSdk reference: eos::nexthop_group_mgr::exists
	Exists(context.Context, *NexthopGroupExistsRequest) (*NexthopGroupExistsResponse, error)
	// *
	// Queries whether a nexthop group is active
	//
	// EosSdk reference: eos::nexthop_group_mgr::active
	Active(context.Context, *NexthopGroupActiveRequest) (*NexthopGroupActiveResponse, error)
	// *
	// Creates or updates a nexthop group and returns its version ID.
	//
	// EosSdk reference: eos::nexthop_group_mgr::nexthop_group_set
	NexthopGroupSet(context.Context, *NexthopGroupSetRequest) (*NexthopGroupSetResponse, error)
	// *
	// Creates or updates multiple nexthops groups in a single call and returns their version IDs.
	//
	// EosSdk reference: eos::nexthop_group_mgr::nexthop_group_set
	BulkNexthopGroupSet(context.Context, *BulkNexthopGroupSetRequest) (*BulkNexthopGroupSetResponse, error)
	// *
	// Deletes a nexthop group.
	//
	// EosSdk reference: eos::nexthop_group_mgr::nexthop_group_del
	NexthopGroupDel(context.Context, *NexthopGroupDelRequest) (*NexthopGroupDelResponse, error)
	// *
	// Deletes multiple nexthop groups in a single call.
	//
	// EosSdk reference: eos::nexthop_group_mgr::nexthop_group_del
	BulkNexthopGroupDel(context.Context, *BulkNexthopGroupDelRequest) (*BulkNexthopGroupDelResponse, error)
	// *
	// Queries a programmed nexthop group by name.
	//
	// EosSdk reference: eos::nexthop_group_mgr::programmed_nexthop_group
	ProgrammedNexthopGroup(context.Context, *ProgrammedNexthopGroupRequest) (*ProgrammedNexthopGroupResponse, error)
}

// UnimplementedNexthopGroupMgrServiceServer should be embedded to have forward compatible implementations.
type UnimplementedNexthopGroupMgrServiceServer struct {
}

func (UnimplementedNexthopGroupMgrServiceServer) Watch(*WatchNexthopGroupRequest, NexthopGroupMgrService_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) ResyncInit(context.Context, *ResyncNexthopGroupInitRequest) (*ResyncNexthopGroupInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResyncInit not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) ResyncComplete(context.Context, *ResyncNexthopGroupCompleteRequest) (*ResyncNexthopGroupCompleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResyncComplete not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) NexthopGroups(*NexthopGroupsRequest, NexthopGroupMgrService_NexthopGroupsServer) error {
	return status.Errorf(codes.Unimplemented, "method NexthopGroups not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) ProgrammedNexthopGroups(*ProgrammedNexthopGroupsRequest, NexthopGroupMgrService_ProgrammedNexthopGroupsServer) error {
	return status.Errorf(codes.Unimplemented, "method ProgrammedNexthopGroups not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) NexthopGroup(context.Context, *NexthopGroupRequest) (*NexthopGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NexthopGroup not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) Counter(context.Context, *CounterRequest) (*CounterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Counter not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) NhgCounters(*NexthopGroupCountersRequest, NexthopGroupMgrService_NhgCountersServer) error {
	return status.Errorf(codes.Unimplemented, "method NhgCounters not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) Exists(context.Context, *NexthopGroupExistsRequest) (*NexthopGroupExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exists not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) Active(context.Context, *NexthopGroupActiveRequest) (*NexthopGroupActiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Active not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) NexthopGroupSet(context.Context, *NexthopGroupSetRequest) (*NexthopGroupSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NexthopGroupSet not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) BulkNexthopGroupSet(context.Context, *BulkNexthopGroupSetRequest) (*BulkNexthopGroupSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkNexthopGroupSet not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) NexthopGroupDel(context.Context, *NexthopGroupDelRequest) (*NexthopGroupDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NexthopGroupDel not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) BulkNexthopGroupDel(context.Context, *BulkNexthopGroupDelRequest) (*BulkNexthopGroupDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkNexthopGroupDel not implemented")
}
func (UnimplementedNexthopGroupMgrServiceServer) ProgrammedNexthopGroup(context.Context, *ProgrammedNexthopGroupRequest) (*ProgrammedNexthopGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProgrammedNexthopGroup not implemented")
}

// UnsafeNexthopGroupMgrServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NexthopGroupMgrServiceServer will
// result in compilation errors.
type UnsafeNexthopGroupMgrServiceServer interface {
	mustEmbedUnimplementedNexthopGroupMgrServiceServer()
}

func RegisterNexthopGroupMgrServiceServer(s grpc.ServiceRegistrar, srv NexthopGroupMgrServiceServer) {
	s.RegisterService(&NexthopGroupMgrService_ServiceDesc, srv)
}

func _NexthopGroupMgrService_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchNexthopGroupRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NexthopGroupMgrServiceServer).Watch(m, &nexthopGroupMgrServiceWatchServer{stream})
}

type NexthopGroupMgrService_WatchServer interface {
	Send(*WatchNexthopGroupResponse) error
	grpc.ServerStream
}

type nexthopGroupMgrServiceWatchServer struct {
	grpc.ServerStream
}

func (x *nexthopGroupMgrServiceWatchServer) Send(m *WatchNexthopGroupResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _NexthopGroupMgrService_ResyncInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResyncNexthopGroupInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NexthopGroupMgrServiceServer).ResyncInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.NexthopGroupMgrService/resync_init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NexthopGroupMgrServiceServer).ResyncInit(ctx, req.(*ResyncNexthopGroupInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NexthopGroupMgrService_ResyncComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResyncNexthopGroupCompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NexthopGroupMgrServiceServer).ResyncComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.NexthopGroupMgrService/resync_complete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NexthopGroupMgrServiceServer).ResyncComplete(ctx, req.(*ResyncNexthopGroupCompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NexthopGroupMgrService_NexthopGroups_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NexthopGroupsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NexthopGroupMgrServiceServer).NexthopGroups(m, &nexthopGroupMgrServiceNexthopGroupsServer{stream})
}

type NexthopGroupMgrService_NexthopGroupsServer interface {
	Send(*NexthopGroupsResponse) error
	grpc.ServerStream
}

type nexthopGroupMgrServiceNexthopGroupsServer struct {
	grpc.ServerStream
}

func (x *nexthopGroupMgrServiceNexthopGroupsServer) Send(m *NexthopGroupsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _NexthopGroupMgrService_ProgrammedNexthopGroups_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProgrammedNexthopGroupsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NexthopGroupMgrServiceServer).ProgrammedNexthopGroups(m, &nexthopGroupMgrServiceProgrammedNexthopGroupsServer{stream})
}

type NexthopGroupMgrService_ProgrammedNexthopGroupsServer interface {
	Send(*ProgrammedNexthopGroupsResponse) error
	grpc.ServerStream
}

type nexthopGroupMgrServiceProgrammedNexthopGroupsServer struct {
	grpc.ServerStream
}

func (x *nexthopGroupMgrServiceProgrammedNexthopGroupsServer) Send(m *ProgrammedNexthopGroupsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _NexthopGroupMgrService_NexthopGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NexthopGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NexthopGroupMgrServiceServer).NexthopGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.NexthopGroupMgrService/nexthop_group",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NexthopGroupMgrServiceServer).NexthopGroup(ctx, req.(*NexthopGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NexthopGroupMgrService_Counter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CounterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NexthopGroupMgrServiceServer).Counter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.NexthopGroupMgrService/counter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NexthopGroupMgrServiceServer).Counter(ctx, req.(*CounterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NexthopGroupMgrService_NhgCounters_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NexthopGroupCountersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NexthopGroupMgrServiceServer).NhgCounters(m, &nexthopGroupMgrServiceNhgCountersServer{stream})
}

type NexthopGroupMgrService_NhgCountersServer interface {
	Send(*NexthopGroupCountersResponse) error
	grpc.ServerStream
}

type nexthopGroupMgrServiceNhgCountersServer struct {
	grpc.ServerStream
}

func (x *nexthopGroupMgrServiceNhgCountersServer) Send(m *NexthopGroupCountersResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _NexthopGroupMgrService_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NexthopGroupExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NexthopGroupMgrServiceServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.NexthopGroupMgrService/exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NexthopGroupMgrServiceServer).Exists(ctx, req.(*NexthopGroupExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NexthopGroupMgrService_Active_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NexthopGroupActiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NexthopGroupMgrServiceServer).Active(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.NexthopGroupMgrService/active",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NexthopGroupMgrServiceServer).Active(ctx, req.(*NexthopGroupActiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NexthopGroupMgrService_NexthopGroupSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NexthopGroupSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NexthopGroupMgrServiceServer).NexthopGroupSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.NexthopGroupMgrService/nexthop_group_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NexthopGroupMgrServiceServer).NexthopGroupSet(ctx, req.(*NexthopGroupSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NexthopGroupMgrService_BulkNexthopGroupSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkNexthopGroupSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NexthopGroupMgrServiceServer).BulkNexthopGroupSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.NexthopGroupMgrService/bulk_nexthop_group_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NexthopGroupMgrServiceServer).BulkNexthopGroupSet(ctx, req.(*BulkNexthopGroupSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NexthopGroupMgrService_NexthopGroupDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NexthopGroupDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NexthopGroupMgrServiceServer).NexthopGroupDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.NexthopGroupMgrService/nexthop_group_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NexthopGroupMgrServiceServer).NexthopGroupDel(ctx, req.(*NexthopGroupDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NexthopGroupMgrService_BulkNexthopGroupDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkNexthopGroupDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NexthopGroupMgrServiceServer).BulkNexthopGroupDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.NexthopGroupMgrService/bulk_nexthop_group_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NexthopGroupMgrServiceServer).BulkNexthopGroupDel(ctx, req.(*BulkNexthopGroupDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NexthopGroupMgrService_ProgrammedNexthopGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProgrammedNexthopGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NexthopGroupMgrServiceServer).ProgrammedNexthopGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.NexthopGroupMgrService/programmed_nexthop_group",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NexthopGroupMgrServiceServer).ProgrammedNexthopGroup(ctx, req.(*ProgrammedNexthopGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NexthopGroupMgrService_ServiceDesc is the grpc.ServiceDesc for NexthopGroupMgrService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NexthopGroupMgrService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eos.remote.NexthopGroupMgrService",
	HandlerType: (*NexthopGroupMgrServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "resync_init",
			Handler:    _NexthopGroupMgrService_ResyncInit_Handler,
		},
		{
			MethodName: "resync_complete",
			Handler:    _NexthopGroupMgrService_ResyncComplete_Handler,
		},
		{
			MethodName: "nexthop_group",
			Handler:    _NexthopGroupMgrService_NexthopGroup_Handler,
		},
		{
			MethodName: "counter",
			Handler:    _NexthopGroupMgrService_Counter_Handler,
		},
		{
			MethodName: "exists",
			Handler:    _NexthopGroupMgrService_Exists_Handler,
		},
		{
			MethodName: "active",
			Handler:    _NexthopGroupMgrService_Active_Handler,
		},
		{
			MethodName: "nexthop_group_set",
			Handler:    _NexthopGroupMgrService_NexthopGroupSet_Handler,
		},
		{
			MethodName: "bulk_nexthop_group_set",
			Handler:    _NexthopGroupMgrService_BulkNexthopGroupSet_Handler,
		},
		{
			MethodName: "nexthop_group_del",
			Handler:    _NexthopGroupMgrService_NexthopGroupDel_Handler,
		},
		{
			MethodName: "bulk_nexthop_group_del",
			Handler:    _NexthopGroupMgrService_BulkNexthopGroupDel_Handler,
		},
		{
			MethodName: "programmed_nexthop_group",
			Handler:    _NexthopGroupMgrService_ProgrammedNexthopGroup_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "watch",
			Handler:       _NexthopGroupMgrService_Watch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "nexthop_groups",
			Handler:       _NexthopGroupMgrService_NexthopGroups_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "programmed_nexthop_groups",
			Handler:       _NexthopGroupMgrService_ProgrammedNexthopGroups_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "nhg_counters",
			Handler:       _NexthopGroupMgrService_NhgCounters_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "nexthop_group.proto",
}
