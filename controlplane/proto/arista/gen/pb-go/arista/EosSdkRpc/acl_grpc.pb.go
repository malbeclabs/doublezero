// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.6
// source: acl.proto

package EosSdkRpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AclMgrServiceClient is the client API for AclMgrService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AclMgrServiceClient interface {
	// *
	// Subscription to monitor ACL hardware synchronization events. This request stays
	// active until the client cancels or the server shuts down.
	//
	// EosSdk reference: eos::acl_handler (class)
	Watch(ctx context.Context, in *AclWatchRequest, opts ...grpc.CallOption) (AclMgrService_WatchClient, error)
	// *
	// Returns a list of the ACLs created by this application.
	//
	// EosSdk reference: eos::acl_mgr::acl_iter
	Acls(ctx context.Context, in *AclsRequest, opts ...grpc.CallOption) (AclMgrService_AclsClient, error)
	// *
	// Returns a list of all the ACLs.
	//
	// EosSdk reference: eos::acl_mgr::acl_all_iter
	AclsAll(ctx context.Context, in *AclsAllRequest, opts ...grpc.CallOption) (AclMgrService_AclsAllClient, error)
	// *
	// Returns a list of all the IP ACL rules created by this application for a
	// specified ACL.
	//
	// EosSdk reference: eos::acl_mgr::acl_rule_ip_iter
	AclRuleIps(ctx context.Context, in *AclRuleIpsRequest, opts ...grpc.CallOption) (AclMgrService_AclRuleIpsClient, error)
	// *
	// Returns a list of all the IP ACL rules for a specified ACL.
	//
	// EosSdk reference: eos::acl_mgr::acl_all_rule_ip_iter
	AclAllRuleIps(ctx context.Context, in *AclAllRuleIpsRequest, opts ...grpc.CallOption) (AclMgrService_AclAllRuleIpsClient, error)
	// *
	// Returns a list of all the ethernet ACL rules created by this application for a
	// specified ACL.
	//
	// EosSdk reference: eos::acl_mgr::acl_rule_eth_iter
	AclRuleEths(ctx context.Context, in *AclRuleEthsRequest, opts ...grpc.CallOption) (AclMgrService_AclRuleEthsClient, error)
	// *
	// Returns a list of all the ethernet ACL rules for a specified ACL.
	//
	// EosSdk reference: eos::acl_mgr::acl_all_rule_eth_iter
	AclAllRuleEths(ctx context.Context, in *AclAllRuleEthsRequest, opts ...grpc.CallOption) (AclMgrService_AclAllRuleEthsClient, error)
	// *
	// Queries whether the specified ACL has been configured in this application.
	//
	// EosSdk reference: eos::acl_mgr::acl_exists
	AclExists(ctx context.Context, in *AclExistsRequest, opts ...grpc.CallOption) (*AclExistsResponse, error)
	// *
	// Queries whether the specified ACL has been configured.
	//
	// EosSdk reference: eos::acl_mgr::acl_all_exists
	AclAllExists(ctx context.Context, in *AclAllExistsRequest, opts ...grpc.CallOption) (*AclAllExistsResponse, error)
	// *
	// Adds a rule to an ACL. If the specified ACL does not exist it is created.
	// The type of the rule must be the same as the ACL's type.
	//
	// Note: Must call acl_commit for this change to take effect
	// Note: An extremely large numbers of ACLs or rules per ACL can result in
	//
	//	undefined behavior, including a switch reload.
	//
	// EosSdk reference: eos::acl_mgr::acl_rule_set
	AclRuleSet(ctx context.Context, in *AclRuleSetRequest, opts ...grpc.CallOption) (*AclRuleSetResponse, error)
	// *
	// Adds multiple rules to ACLs in a single call. Creates any ACLs that do not
	// exist.
	//
	// Note: Must call acl_commit for this change to take effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_rule_set
	BulkAclRuleSet(ctx context.Context, in *BulkAclRuleSetRequest, opts ...grpc.CallOption) (*BulkAclRuleSetResponse, error)
	// *
	// Removes a rule from an ACL. If the specified ACL does not exist or there is no
	// rule at the specified sequence number no changes are made.
	//
	// Note: Must call acl_commit for this change to take effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_rule_del
	AclRuleDel(ctx context.Context, in *AclRuleDelRequest, opts ...grpc.CallOption) (*AclRuleDelResponse, error)
	// *
	// Removes multiple rules from ACLs in a single call.
	//
	// Note: Must call acl_commit for this change to take effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_rule_del
	BulkAclRuleDel(ctx context.Context, in *BulkAclRuleDelRequest, opts ...grpc.CallOption) (*BulkAclRuleDelResponse, error)
	// *
	// Commits all rule and setting changes made to all ACLs.
	//
	// Pushes ACLs into Sysdb's active configuration. This commit cannot fail, but it
	// can lead to a state where not all ACLs can be loaded into hardware. You will be
	// notified via an on_acl_sync event when this commit and all other outstanding
	// operations such as interface applications are loaded into hardware, or
	// an on_acl_sync_fail event if the newly committed configuration can't be loaded.
	// If there are no changes pending, you will get one of those events depending on
	// whether the current state in Sysdb can be loaded into hardware or not.
	//
	// EosSdk reference: eos::acl_mgr::acl_commit
	AclCommit(ctx context.Context, in *AclCommitRequest, opts ...grpc.CallOption) (*AclCommitResponse, error)
	// *
	// Deletes the specified ACL removing it from all interfaces and removing all of
	// its rules. Any pending changes to the ACL are discarded. It is effective
	// immediately (no commit needed and no watcher event is provided).
	//
	// EosSdk reference: eos::acl_mgr::acl_del
	AclDel(ctx context.Context, in *AclDelRequest, opts ...grpc.CallOption) (*AclDelResponse, error)
	// *
	// Deletes multiple ACLs in a single call.
	//
	// EosSdk reference: eos::acl_mgr::acl_del
	BulkAclDel(ctx context.Context, in *BulkAclDelRequest, opts ...grpc.CallOption) (*BulkAclDelResponse, error)
	// *
	// Requests that an ACL be (un)applied on the given interface and direction.
	//
	// ACL is loaded into hardware asynchronously. Like acl_commit, this call
	// results in a watcher event when we have applied, or failed to apply, this
	// ACL configuration. That is, an event will not be sent per call but instead an
	// event will be sent when everything is loaded into hardware, or when we notice
	// problems.
	//
	// API call ordering note: any acl_rule_set or acl_rule_del calls must be
	// followed by an acl_commit prior to calling this rpc otherwise this call
	// will return an error.
	//
	// EosSdk reference: eos::acl_mgr::acl_apply
	AclApply(ctx context.Context, in *AclApplyRequest, opts ...grpc.CallOption) (*AclApplyResponse, error)
	// *
	// Apply or unapply multiple ACLs on the specified interfaces and directions in a
	// single call.
	//
	// EosSdk reference: eos::acl_mgr::acl_apply
	BulkAclApply(ctx context.Context, in *BulkAclApplyRequest, opts ...grpc.CallOption) (*BulkAclApplyResponse, error)
	// *
	// Enable or disable counters for the ACL.
	//
	// Note: Must call acl_commit before this setting takes effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_counters_enabled_set
	AclCountersEnabledSet(ctx context.Context, in *AclCountersEnabledSetRequest, opts ...grpc.CallOption) (*AclCountersEnabledSetResponse, error)
	// *
	// Enable or disable counters for multiple ACLs in a single call.
	//
	// Note: Must call acl_commit before this setting takes effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_counters_enabled_set
	BulkAclCountersEnabledSet(ctx context.Context, in *BulkAclCountersEnabledSetRequest, opts ...grpc.CallOption) (*BulkAclCountersEnabledSetResponse, error)
	// *
	// Enable or disable fragments matching on the ACL.
	//
	// Note: Must call acl_commit before this setting takes effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_fragments_enabled_set
	AclFragmentsEnabledSet(ctx context.Context, in *AclFragmentsEnabledSetRequest, opts ...grpc.CallOption) (*AclFragmentsEnabledSetResponse, error)
	// *
	// Enables or disables fragments matching on multiple ACLs in a single call.
	//
	// Note: Must call acl_commit before this setting takes effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_fragments_enabled_set
	BulkAclFragmentsEnabledSet(ctx context.Context, in *BulkAclFragmentsEnabledSetRequest, opts ...grpc.CallOption) (*BulkAclFragmentsEnabledSetResponse, error)
	// *
	// Check a connection against any applied ACL to determine if it should be
	// dropped, incrementing the ACL counter if so. For use with SOCK_STREAM or
	// SOCK_DGRAM.
	//
	// EosSdk reference: eos::acl_mgr::stream_allowed
	StreamAllowed(ctx context.Context, in *StreamAllowedRequest, opts ...grpc.CallOption) (*StreamAllowedResponse, error)
	// *
	// Check a packet against any applied ACL to determine if it should be dropped,
	// incrementing the ACL counter if so. For use with SOCK_DGRAM only.
	//
	// EosSdk reference: eos::acl_mgr::dgram_allowed
	DgramAllowed(ctx context.Context, in *DgramAllowedRequest, opts ...grpc.CallOption) (*DgramAllowedResponse, error)
}

type aclMgrServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAclMgrServiceClient(cc grpc.ClientConnInterface) AclMgrServiceClient {
	return &aclMgrServiceClient{cc}
}

func (c *aclMgrServiceClient) Watch(ctx context.Context, in *AclWatchRequest, opts ...grpc.CallOption) (AclMgrService_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &AclMgrService_ServiceDesc.Streams[0], "/eos.remote.AclMgrService/watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &aclMgrServiceWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AclMgrService_WatchClient interface {
	Recv() (*AclWatchResponse, error)
	grpc.ClientStream
}

type aclMgrServiceWatchClient struct {
	grpc.ClientStream
}

func (x *aclMgrServiceWatchClient) Recv() (*AclWatchResponse, error) {
	m := new(AclWatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aclMgrServiceClient) Acls(ctx context.Context, in *AclsRequest, opts ...grpc.CallOption) (AclMgrService_AclsClient, error) {
	stream, err := c.cc.NewStream(ctx, &AclMgrService_ServiceDesc.Streams[1], "/eos.remote.AclMgrService/acls", opts...)
	if err != nil {
		return nil, err
	}
	x := &aclMgrServiceAclsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AclMgrService_AclsClient interface {
	Recv() (*AclsResponse, error)
	grpc.ClientStream
}

type aclMgrServiceAclsClient struct {
	grpc.ClientStream
}

func (x *aclMgrServiceAclsClient) Recv() (*AclsResponse, error) {
	m := new(AclsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aclMgrServiceClient) AclsAll(ctx context.Context, in *AclsAllRequest, opts ...grpc.CallOption) (AclMgrService_AclsAllClient, error) {
	stream, err := c.cc.NewStream(ctx, &AclMgrService_ServiceDesc.Streams[2], "/eos.remote.AclMgrService/acls_all", opts...)
	if err != nil {
		return nil, err
	}
	x := &aclMgrServiceAclsAllClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AclMgrService_AclsAllClient interface {
	Recv() (*AclsAllResponse, error)
	grpc.ClientStream
}

type aclMgrServiceAclsAllClient struct {
	grpc.ClientStream
}

func (x *aclMgrServiceAclsAllClient) Recv() (*AclsAllResponse, error) {
	m := new(AclsAllResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aclMgrServiceClient) AclRuleIps(ctx context.Context, in *AclRuleIpsRequest, opts ...grpc.CallOption) (AclMgrService_AclRuleIpsClient, error) {
	stream, err := c.cc.NewStream(ctx, &AclMgrService_ServiceDesc.Streams[3], "/eos.remote.AclMgrService/acl_rule_ips", opts...)
	if err != nil {
		return nil, err
	}
	x := &aclMgrServiceAclRuleIpsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AclMgrService_AclRuleIpsClient interface {
	Recv() (*AclRuleIpsResponse, error)
	grpc.ClientStream
}

type aclMgrServiceAclRuleIpsClient struct {
	grpc.ClientStream
}

func (x *aclMgrServiceAclRuleIpsClient) Recv() (*AclRuleIpsResponse, error) {
	m := new(AclRuleIpsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aclMgrServiceClient) AclAllRuleIps(ctx context.Context, in *AclAllRuleIpsRequest, opts ...grpc.CallOption) (AclMgrService_AclAllRuleIpsClient, error) {
	stream, err := c.cc.NewStream(ctx, &AclMgrService_ServiceDesc.Streams[4], "/eos.remote.AclMgrService/acl_all_rule_ips", opts...)
	if err != nil {
		return nil, err
	}
	x := &aclMgrServiceAclAllRuleIpsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AclMgrService_AclAllRuleIpsClient interface {
	Recv() (*AclAllRuleIpsResponse, error)
	grpc.ClientStream
}

type aclMgrServiceAclAllRuleIpsClient struct {
	grpc.ClientStream
}

func (x *aclMgrServiceAclAllRuleIpsClient) Recv() (*AclAllRuleIpsResponse, error) {
	m := new(AclAllRuleIpsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aclMgrServiceClient) AclRuleEths(ctx context.Context, in *AclRuleEthsRequest, opts ...grpc.CallOption) (AclMgrService_AclRuleEthsClient, error) {
	stream, err := c.cc.NewStream(ctx, &AclMgrService_ServiceDesc.Streams[5], "/eos.remote.AclMgrService/acl_rule_eths", opts...)
	if err != nil {
		return nil, err
	}
	x := &aclMgrServiceAclRuleEthsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AclMgrService_AclRuleEthsClient interface {
	Recv() (*AclRuleEthsResponse, error)
	grpc.ClientStream
}

type aclMgrServiceAclRuleEthsClient struct {
	grpc.ClientStream
}

func (x *aclMgrServiceAclRuleEthsClient) Recv() (*AclRuleEthsResponse, error) {
	m := new(AclRuleEthsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aclMgrServiceClient) AclAllRuleEths(ctx context.Context, in *AclAllRuleEthsRequest, opts ...grpc.CallOption) (AclMgrService_AclAllRuleEthsClient, error) {
	stream, err := c.cc.NewStream(ctx, &AclMgrService_ServiceDesc.Streams[6], "/eos.remote.AclMgrService/acl_all_rule_eths", opts...)
	if err != nil {
		return nil, err
	}
	x := &aclMgrServiceAclAllRuleEthsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AclMgrService_AclAllRuleEthsClient interface {
	Recv() (*AclAllRuleEthsResponse, error)
	grpc.ClientStream
}

type aclMgrServiceAclAllRuleEthsClient struct {
	grpc.ClientStream
}

func (x *aclMgrServiceAclAllRuleEthsClient) Recv() (*AclAllRuleEthsResponse, error) {
	m := new(AclAllRuleEthsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aclMgrServiceClient) AclExists(ctx context.Context, in *AclExistsRequest, opts ...grpc.CallOption) (*AclExistsResponse, error) {
	out := new(AclExistsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/acl_exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) AclAllExists(ctx context.Context, in *AclAllExistsRequest, opts ...grpc.CallOption) (*AclAllExistsResponse, error) {
	out := new(AclAllExistsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/acl_all_exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) AclRuleSet(ctx context.Context, in *AclRuleSetRequest, opts ...grpc.CallOption) (*AclRuleSetResponse, error) {
	out := new(AclRuleSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/acl_rule_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) BulkAclRuleSet(ctx context.Context, in *BulkAclRuleSetRequest, opts ...grpc.CallOption) (*BulkAclRuleSetResponse, error) {
	out := new(BulkAclRuleSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/bulk_acl_rule_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) AclRuleDel(ctx context.Context, in *AclRuleDelRequest, opts ...grpc.CallOption) (*AclRuleDelResponse, error) {
	out := new(AclRuleDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/acl_rule_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) BulkAclRuleDel(ctx context.Context, in *BulkAclRuleDelRequest, opts ...grpc.CallOption) (*BulkAclRuleDelResponse, error) {
	out := new(BulkAclRuleDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/bulk_acl_rule_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) AclCommit(ctx context.Context, in *AclCommitRequest, opts ...grpc.CallOption) (*AclCommitResponse, error) {
	out := new(AclCommitResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/acl_commit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) AclDel(ctx context.Context, in *AclDelRequest, opts ...grpc.CallOption) (*AclDelResponse, error) {
	out := new(AclDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/acl_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) BulkAclDel(ctx context.Context, in *BulkAclDelRequest, opts ...grpc.CallOption) (*BulkAclDelResponse, error) {
	out := new(BulkAclDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/bulk_acl_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) AclApply(ctx context.Context, in *AclApplyRequest, opts ...grpc.CallOption) (*AclApplyResponse, error) {
	out := new(AclApplyResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/acl_apply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) BulkAclApply(ctx context.Context, in *BulkAclApplyRequest, opts ...grpc.CallOption) (*BulkAclApplyResponse, error) {
	out := new(BulkAclApplyResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/bulk_acl_apply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) AclCountersEnabledSet(ctx context.Context, in *AclCountersEnabledSetRequest, opts ...grpc.CallOption) (*AclCountersEnabledSetResponse, error) {
	out := new(AclCountersEnabledSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/acl_counters_enabled_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) BulkAclCountersEnabledSet(ctx context.Context, in *BulkAclCountersEnabledSetRequest, opts ...grpc.CallOption) (*BulkAclCountersEnabledSetResponse, error) {
	out := new(BulkAclCountersEnabledSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/bulk_acl_counters_enabled_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) AclFragmentsEnabledSet(ctx context.Context, in *AclFragmentsEnabledSetRequest, opts ...grpc.CallOption) (*AclFragmentsEnabledSetResponse, error) {
	out := new(AclFragmentsEnabledSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/acl_fragments_enabled_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) BulkAclFragmentsEnabledSet(ctx context.Context, in *BulkAclFragmentsEnabledSetRequest, opts ...grpc.CallOption) (*BulkAclFragmentsEnabledSetResponse, error) {
	out := new(BulkAclFragmentsEnabledSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/bulk_acl_fragments_enabled_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) StreamAllowed(ctx context.Context, in *StreamAllowedRequest, opts ...grpc.CallOption) (*StreamAllowedResponse, error) {
	out := new(StreamAllowedResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/stream_allowed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aclMgrServiceClient) DgramAllowed(ctx context.Context, in *DgramAllowedRequest, opts ...grpc.CallOption) (*DgramAllowedResponse, error) {
	out := new(DgramAllowedResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.AclMgrService/dgram_allowed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AclMgrServiceServer is the server API for AclMgrService service.
// All implementations should embed UnimplementedAclMgrServiceServer
// for forward compatibility
type AclMgrServiceServer interface {
	// *
	// Subscription to monitor ACL hardware synchronization events. This request stays
	// active until the client cancels or the server shuts down.
	//
	// EosSdk reference: eos::acl_handler (class)
	Watch(*AclWatchRequest, AclMgrService_WatchServer) error
	// *
	// Returns a list of the ACLs created by this application.
	//
	// EosSdk reference: eos::acl_mgr::acl_iter
	Acls(*AclsRequest, AclMgrService_AclsServer) error
	// *
	// Returns a list of all the ACLs.
	//
	// EosSdk reference: eos::acl_mgr::acl_all_iter
	AclsAll(*AclsAllRequest, AclMgrService_AclsAllServer) error
	// *
	// Returns a list of all the IP ACL rules created by this application for a
	// specified ACL.
	//
	// EosSdk reference: eos::acl_mgr::acl_rule_ip_iter
	AclRuleIps(*AclRuleIpsRequest, AclMgrService_AclRuleIpsServer) error
	// *
	// Returns a list of all the IP ACL rules for a specified ACL.
	//
	// EosSdk reference: eos::acl_mgr::acl_all_rule_ip_iter
	AclAllRuleIps(*AclAllRuleIpsRequest, AclMgrService_AclAllRuleIpsServer) error
	// *
	// Returns a list of all the ethernet ACL rules created by this application for a
	// specified ACL.
	//
	// EosSdk reference: eos::acl_mgr::acl_rule_eth_iter
	AclRuleEths(*AclRuleEthsRequest, AclMgrService_AclRuleEthsServer) error
	// *
	// Returns a list of all the ethernet ACL rules for a specified ACL.
	//
	// EosSdk reference: eos::acl_mgr::acl_all_rule_eth_iter
	AclAllRuleEths(*AclAllRuleEthsRequest, AclMgrService_AclAllRuleEthsServer) error
	// *
	// Queries whether the specified ACL has been configured in this application.
	//
	// EosSdk reference: eos::acl_mgr::acl_exists
	AclExists(context.Context, *AclExistsRequest) (*AclExistsResponse, error)
	// *
	// Queries whether the specified ACL has been configured.
	//
	// EosSdk reference: eos::acl_mgr::acl_all_exists
	AclAllExists(context.Context, *AclAllExistsRequest) (*AclAllExistsResponse, error)
	// *
	// Adds a rule to an ACL. If the specified ACL does not exist it is created.
	// The type of the rule must be the same as the ACL's type.
	//
	// Note: Must call acl_commit for this change to take effect
	// Note: An extremely large numbers of ACLs or rules per ACL can result in
	//
	//	undefined behavior, including a switch reload.
	//
	// EosSdk reference: eos::acl_mgr::acl_rule_set
	AclRuleSet(context.Context, *AclRuleSetRequest) (*AclRuleSetResponse, error)
	// *
	// Adds multiple rules to ACLs in a single call. Creates any ACLs that do not
	// exist.
	//
	// Note: Must call acl_commit for this change to take effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_rule_set
	BulkAclRuleSet(context.Context, *BulkAclRuleSetRequest) (*BulkAclRuleSetResponse, error)
	// *
	// Removes a rule from an ACL. If the specified ACL does not exist or there is no
	// rule at the specified sequence number no changes are made.
	//
	// Note: Must call acl_commit for this change to take effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_rule_del
	AclRuleDel(context.Context, *AclRuleDelRequest) (*AclRuleDelResponse, error)
	// *
	// Removes multiple rules from ACLs in a single call.
	//
	// Note: Must call acl_commit for this change to take effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_rule_del
	BulkAclRuleDel(context.Context, *BulkAclRuleDelRequest) (*BulkAclRuleDelResponse, error)
	// *
	// Commits all rule and setting changes made to all ACLs.
	//
	// Pushes ACLs into Sysdb's active configuration. This commit cannot fail, but it
	// can lead to a state where not all ACLs can be loaded into hardware. You will be
	// notified via an on_acl_sync event when this commit and all other outstanding
	// operations such as interface applications are loaded into hardware, or
	// an on_acl_sync_fail event if the newly committed configuration can't be loaded.
	// If there are no changes pending, you will get one of those events depending on
	// whether the current state in Sysdb can be loaded into hardware or not.
	//
	// EosSdk reference: eos::acl_mgr::acl_commit
	AclCommit(context.Context, *AclCommitRequest) (*AclCommitResponse, error)
	// *
	// Deletes the specified ACL removing it from all interfaces and removing all of
	// its rules. Any pending changes to the ACL are discarded. It is effective
	// immediately (no commit needed and no watcher event is provided).
	//
	// EosSdk reference: eos::acl_mgr::acl_del
	AclDel(context.Context, *AclDelRequest) (*AclDelResponse, error)
	// *
	// Deletes multiple ACLs in a single call.
	//
	// EosSdk reference: eos::acl_mgr::acl_del
	BulkAclDel(context.Context, *BulkAclDelRequest) (*BulkAclDelResponse, error)
	// *
	// Requests that an ACL be (un)applied on the given interface and direction.
	//
	// ACL is loaded into hardware asynchronously. Like acl_commit, this call
	// results in a watcher event when we have applied, or failed to apply, this
	// ACL configuration. That is, an event will not be sent per call but instead an
	// event will be sent when everything is loaded into hardware, or when we notice
	// problems.
	//
	// API call ordering note: any acl_rule_set or acl_rule_del calls must be
	// followed by an acl_commit prior to calling this rpc otherwise this call
	// will return an error.
	//
	// EosSdk reference: eos::acl_mgr::acl_apply
	AclApply(context.Context, *AclApplyRequest) (*AclApplyResponse, error)
	// *
	// Apply or unapply multiple ACLs on the specified interfaces and directions in a
	// single call.
	//
	// EosSdk reference: eos::acl_mgr::acl_apply
	BulkAclApply(context.Context, *BulkAclApplyRequest) (*BulkAclApplyResponse, error)
	// *
	// Enable or disable counters for the ACL.
	//
	// Note: Must call acl_commit before this setting takes effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_counters_enabled_set
	AclCountersEnabledSet(context.Context, *AclCountersEnabledSetRequest) (*AclCountersEnabledSetResponse, error)
	// *
	// Enable or disable counters for multiple ACLs in a single call.
	//
	// Note: Must call acl_commit before this setting takes effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_counters_enabled_set
	BulkAclCountersEnabledSet(context.Context, *BulkAclCountersEnabledSetRequest) (*BulkAclCountersEnabledSetResponse, error)
	// *
	// Enable or disable fragments matching on the ACL.
	//
	// Note: Must call acl_commit before this setting takes effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_fragments_enabled_set
	AclFragmentsEnabledSet(context.Context, *AclFragmentsEnabledSetRequest) (*AclFragmentsEnabledSetResponse, error)
	// *
	// Enables or disables fragments matching on multiple ACLs in a single call.
	//
	// Note: Must call acl_commit before this setting takes effect.
	//
	// EosSdk reference: eos::acl_mgr::acl_fragments_enabled_set
	BulkAclFragmentsEnabledSet(context.Context, *BulkAclFragmentsEnabledSetRequest) (*BulkAclFragmentsEnabledSetResponse, error)
	// *
	// Check a connection against any applied ACL to determine if it should be
	// dropped, incrementing the ACL counter if so. For use with SOCK_STREAM or
	// SOCK_DGRAM.
	//
	// EosSdk reference: eos::acl_mgr::stream_allowed
	StreamAllowed(context.Context, *StreamAllowedRequest) (*StreamAllowedResponse, error)
	// *
	// Check a packet against any applied ACL to determine if it should be dropped,
	// incrementing the ACL counter if so. For use with SOCK_DGRAM only.
	//
	// EosSdk reference: eos::acl_mgr::dgram_allowed
	DgramAllowed(context.Context, *DgramAllowedRequest) (*DgramAllowedResponse, error)
}

// UnimplementedAclMgrServiceServer should be embedded to have forward compatible implementations.
type UnimplementedAclMgrServiceServer struct {
}

func (UnimplementedAclMgrServiceServer) Watch(*AclWatchRequest, AclMgrService_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedAclMgrServiceServer) Acls(*AclsRequest, AclMgrService_AclsServer) error {
	return status.Errorf(codes.Unimplemented, "method Acls not implemented")
}
func (UnimplementedAclMgrServiceServer) AclsAll(*AclsAllRequest, AclMgrService_AclsAllServer) error {
	return status.Errorf(codes.Unimplemented, "method AclsAll not implemented")
}
func (UnimplementedAclMgrServiceServer) AclRuleIps(*AclRuleIpsRequest, AclMgrService_AclRuleIpsServer) error {
	return status.Errorf(codes.Unimplemented, "method AclRuleIps not implemented")
}
func (UnimplementedAclMgrServiceServer) AclAllRuleIps(*AclAllRuleIpsRequest, AclMgrService_AclAllRuleIpsServer) error {
	return status.Errorf(codes.Unimplemented, "method AclAllRuleIps not implemented")
}
func (UnimplementedAclMgrServiceServer) AclRuleEths(*AclRuleEthsRequest, AclMgrService_AclRuleEthsServer) error {
	return status.Errorf(codes.Unimplemented, "method AclRuleEths not implemented")
}
func (UnimplementedAclMgrServiceServer) AclAllRuleEths(*AclAllRuleEthsRequest, AclMgrService_AclAllRuleEthsServer) error {
	return status.Errorf(codes.Unimplemented, "method AclAllRuleEths not implemented")
}
func (UnimplementedAclMgrServiceServer) AclExists(context.Context, *AclExistsRequest) (*AclExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AclExists not implemented")
}
func (UnimplementedAclMgrServiceServer) AclAllExists(context.Context, *AclAllExistsRequest) (*AclAllExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AclAllExists not implemented")
}
func (UnimplementedAclMgrServiceServer) AclRuleSet(context.Context, *AclRuleSetRequest) (*AclRuleSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AclRuleSet not implemented")
}
func (UnimplementedAclMgrServiceServer) BulkAclRuleSet(context.Context, *BulkAclRuleSetRequest) (*BulkAclRuleSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkAclRuleSet not implemented")
}
func (UnimplementedAclMgrServiceServer) AclRuleDel(context.Context, *AclRuleDelRequest) (*AclRuleDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AclRuleDel not implemented")
}
func (UnimplementedAclMgrServiceServer) BulkAclRuleDel(context.Context, *BulkAclRuleDelRequest) (*BulkAclRuleDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkAclRuleDel not implemented")
}
func (UnimplementedAclMgrServiceServer) AclCommit(context.Context, *AclCommitRequest) (*AclCommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AclCommit not implemented")
}
func (UnimplementedAclMgrServiceServer) AclDel(context.Context, *AclDelRequest) (*AclDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AclDel not implemented")
}
func (UnimplementedAclMgrServiceServer) BulkAclDel(context.Context, *BulkAclDelRequest) (*BulkAclDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkAclDel not implemented")
}
func (UnimplementedAclMgrServiceServer) AclApply(context.Context, *AclApplyRequest) (*AclApplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AclApply not implemented")
}
func (UnimplementedAclMgrServiceServer) BulkAclApply(context.Context, *BulkAclApplyRequest) (*BulkAclApplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkAclApply not implemented")
}
func (UnimplementedAclMgrServiceServer) AclCountersEnabledSet(context.Context, *AclCountersEnabledSetRequest) (*AclCountersEnabledSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AclCountersEnabledSet not implemented")
}
func (UnimplementedAclMgrServiceServer) BulkAclCountersEnabledSet(context.Context, *BulkAclCountersEnabledSetRequest) (*BulkAclCountersEnabledSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkAclCountersEnabledSet not implemented")
}
func (UnimplementedAclMgrServiceServer) AclFragmentsEnabledSet(context.Context, *AclFragmentsEnabledSetRequest) (*AclFragmentsEnabledSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AclFragmentsEnabledSet not implemented")
}
func (UnimplementedAclMgrServiceServer) BulkAclFragmentsEnabledSet(context.Context, *BulkAclFragmentsEnabledSetRequest) (*BulkAclFragmentsEnabledSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkAclFragmentsEnabledSet not implemented")
}
func (UnimplementedAclMgrServiceServer) StreamAllowed(context.Context, *StreamAllowedRequest) (*StreamAllowedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StreamAllowed not implemented")
}
func (UnimplementedAclMgrServiceServer) DgramAllowed(context.Context, *DgramAllowedRequest) (*DgramAllowedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DgramAllowed not implemented")
}

// UnsafeAclMgrServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AclMgrServiceServer will
// result in compilation errors.
type UnsafeAclMgrServiceServer interface {
	mustEmbedUnimplementedAclMgrServiceServer()
}

func RegisterAclMgrServiceServer(s grpc.ServiceRegistrar, srv AclMgrServiceServer) {
	s.RegisterService(&AclMgrService_ServiceDesc, srv)
}

func _AclMgrService_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AclWatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AclMgrServiceServer).Watch(m, &aclMgrServiceWatchServer{stream})
}

type AclMgrService_WatchServer interface {
	Send(*AclWatchResponse) error
	grpc.ServerStream
}

type aclMgrServiceWatchServer struct {
	grpc.ServerStream
}

func (x *aclMgrServiceWatchServer) Send(m *AclWatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AclMgrService_Acls_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AclsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AclMgrServiceServer).Acls(m, &aclMgrServiceAclsServer{stream})
}

type AclMgrService_AclsServer interface {
	Send(*AclsResponse) error
	grpc.ServerStream
}

type aclMgrServiceAclsServer struct {
	grpc.ServerStream
}

func (x *aclMgrServiceAclsServer) Send(m *AclsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AclMgrService_AclsAll_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AclsAllRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AclMgrServiceServer).AclsAll(m, &aclMgrServiceAclsAllServer{stream})
}

type AclMgrService_AclsAllServer interface {
	Send(*AclsAllResponse) error
	grpc.ServerStream
}

type aclMgrServiceAclsAllServer struct {
	grpc.ServerStream
}

func (x *aclMgrServiceAclsAllServer) Send(m *AclsAllResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AclMgrService_AclRuleIps_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AclRuleIpsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AclMgrServiceServer).AclRuleIps(m, &aclMgrServiceAclRuleIpsServer{stream})
}

type AclMgrService_AclRuleIpsServer interface {
	Send(*AclRuleIpsResponse) error
	grpc.ServerStream
}

type aclMgrServiceAclRuleIpsServer struct {
	grpc.ServerStream
}

func (x *aclMgrServiceAclRuleIpsServer) Send(m *AclRuleIpsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AclMgrService_AclAllRuleIps_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AclAllRuleIpsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AclMgrServiceServer).AclAllRuleIps(m, &aclMgrServiceAclAllRuleIpsServer{stream})
}

type AclMgrService_AclAllRuleIpsServer interface {
	Send(*AclAllRuleIpsResponse) error
	grpc.ServerStream
}

type aclMgrServiceAclAllRuleIpsServer struct {
	grpc.ServerStream
}

func (x *aclMgrServiceAclAllRuleIpsServer) Send(m *AclAllRuleIpsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AclMgrService_AclRuleEths_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AclRuleEthsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AclMgrServiceServer).AclRuleEths(m, &aclMgrServiceAclRuleEthsServer{stream})
}

type AclMgrService_AclRuleEthsServer interface {
	Send(*AclRuleEthsResponse) error
	grpc.ServerStream
}

type aclMgrServiceAclRuleEthsServer struct {
	grpc.ServerStream
}

func (x *aclMgrServiceAclRuleEthsServer) Send(m *AclRuleEthsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AclMgrService_AclAllRuleEths_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AclAllRuleEthsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AclMgrServiceServer).AclAllRuleEths(m, &aclMgrServiceAclAllRuleEthsServer{stream})
}

type AclMgrService_AclAllRuleEthsServer interface {
	Send(*AclAllRuleEthsResponse) error
	grpc.ServerStream
}

type aclMgrServiceAclAllRuleEthsServer struct {
	grpc.ServerStream
}

func (x *aclMgrServiceAclAllRuleEthsServer) Send(m *AclAllRuleEthsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _AclMgrService_AclExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).AclExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/acl_exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).AclExists(ctx, req.(*AclExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_AclAllExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclAllExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).AclAllExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/acl_all_exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).AclAllExists(ctx, req.(*AclAllExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_AclRuleSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclRuleSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).AclRuleSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/acl_rule_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).AclRuleSet(ctx, req.(*AclRuleSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_BulkAclRuleSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkAclRuleSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).BulkAclRuleSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/bulk_acl_rule_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).BulkAclRuleSet(ctx, req.(*BulkAclRuleSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_AclRuleDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclRuleDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).AclRuleDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/acl_rule_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).AclRuleDel(ctx, req.(*AclRuleDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_BulkAclRuleDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkAclRuleDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).BulkAclRuleDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/bulk_acl_rule_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).BulkAclRuleDel(ctx, req.(*BulkAclRuleDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_AclCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).AclCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/acl_commit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).AclCommit(ctx, req.(*AclCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_AclDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).AclDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/acl_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).AclDel(ctx, req.(*AclDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_BulkAclDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkAclDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).BulkAclDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/bulk_acl_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).BulkAclDel(ctx, req.(*BulkAclDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_AclApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).AclApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/acl_apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).AclApply(ctx, req.(*AclApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_BulkAclApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkAclApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).BulkAclApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/bulk_acl_apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).BulkAclApply(ctx, req.(*BulkAclApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_AclCountersEnabledSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclCountersEnabledSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).AclCountersEnabledSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/acl_counters_enabled_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).AclCountersEnabledSet(ctx, req.(*AclCountersEnabledSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_BulkAclCountersEnabledSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkAclCountersEnabledSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).BulkAclCountersEnabledSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/bulk_acl_counters_enabled_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).BulkAclCountersEnabledSet(ctx, req.(*BulkAclCountersEnabledSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_AclFragmentsEnabledSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AclFragmentsEnabledSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).AclFragmentsEnabledSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/acl_fragments_enabled_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).AclFragmentsEnabledSet(ctx, req.(*AclFragmentsEnabledSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_BulkAclFragmentsEnabledSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkAclFragmentsEnabledSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).BulkAclFragmentsEnabledSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/bulk_acl_fragments_enabled_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).BulkAclFragmentsEnabledSet(ctx, req.(*BulkAclFragmentsEnabledSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_StreamAllowed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StreamAllowedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).StreamAllowed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/stream_allowed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).StreamAllowed(ctx, req.(*StreamAllowedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AclMgrService_DgramAllowed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DgramAllowedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AclMgrServiceServer).DgramAllowed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.AclMgrService/dgram_allowed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AclMgrServiceServer).DgramAllowed(ctx, req.(*DgramAllowedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AclMgrService_ServiceDesc is the grpc.ServiceDesc for AclMgrService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AclMgrService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eos.remote.AclMgrService",
	HandlerType: (*AclMgrServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "acl_exists",
			Handler:    _AclMgrService_AclExists_Handler,
		},
		{
			MethodName: "acl_all_exists",
			Handler:    _AclMgrService_AclAllExists_Handler,
		},
		{
			MethodName: "acl_rule_set",
			Handler:    _AclMgrService_AclRuleSet_Handler,
		},
		{
			MethodName: "bulk_acl_rule_set",
			Handler:    _AclMgrService_BulkAclRuleSet_Handler,
		},
		{
			MethodName: "acl_rule_del",
			Handler:    _AclMgrService_AclRuleDel_Handler,
		},
		{
			MethodName: "bulk_acl_rule_del",
			Handler:    _AclMgrService_BulkAclRuleDel_Handler,
		},
		{
			MethodName: "acl_commit",
			Handler:    _AclMgrService_AclCommit_Handler,
		},
		{
			MethodName: "acl_del",
			Handler:    _AclMgrService_AclDel_Handler,
		},
		{
			MethodName: "bulk_acl_del",
			Handler:    _AclMgrService_BulkAclDel_Handler,
		},
		{
			MethodName: "acl_apply",
			Handler:    _AclMgrService_AclApply_Handler,
		},
		{
			MethodName: "bulk_acl_apply",
			Handler:    _AclMgrService_BulkAclApply_Handler,
		},
		{
			MethodName: "acl_counters_enabled_set",
			Handler:    _AclMgrService_AclCountersEnabledSet_Handler,
		},
		{
			MethodName: "bulk_acl_counters_enabled_set",
			Handler:    _AclMgrService_BulkAclCountersEnabledSet_Handler,
		},
		{
			MethodName: "acl_fragments_enabled_set",
			Handler:    _AclMgrService_AclFragmentsEnabledSet_Handler,
		},
		{
			MethodName: "bulk_acl_fragments_enabled_set",
			Handler:    _AclMgrService_BulkAclFragmentsEnabledSet_Handler,
		},
		{
			MethodName: "stream_allowed",
			Handler:    _AclMgrService_StreamAllowed_Handler,
		},
		{
			MethodName: "dgram_allowed",
			Handler:    _AclMgrService_DgramAllowed_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "watch",
			Handler:       _AclMgrService_Watch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "acls",
			Handler:       _AclMgrService_Acls_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "acls_all",
			Handler:       _AclMgrService_AclsAll_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "acl_rule_ips",
			Handler:       _AclMgrService_AclRuleIps_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "acl_all_rule_ips",
			Handler:       _AclMgrService_AclAllRuleIps_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "acl_rule_eths",
			Handler:       _AclMgrService_AclRuleEths_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "acl_all_rule_eths",
			Handler:       _AclMgrService_AclAllRuleEths_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "acl.proto",
}
