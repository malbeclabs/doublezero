// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.6
// source: ip_route.proto

package EosSdkRpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// IpRouteMgrServiceClient is the client API for IpRouteMgrService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IpRouteMgrServiceClient interface {
	// *
	// Queries for the current tag assigned to the ip route manager.
	//
	// EosSdk reference: eos::ip_route_mgr::tag
	Tag(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*TagResponse, error)
	// *
	// Sets the current tag for the ip route manager.
	// This service will only interact with routes with the given tag.
	//
	// EosSdk reference: eos::ip_route_mgr::tag_is
	TagIs(ctx context.Context, in *TagIsRequest, opts ...grpc.CallOption) (*TagIsResponse, error)
	// *
	// Starts the route resync process, to set the routes to a known state.
	// The resync_complete rpc, must be called to end the resync.
	// Please check the EosSdk reference for further details.
	//
	// EosSdk reference: eos::ip_route_mgr::resync_init
	ResyncInit(ctx context.Context, in *IpRouteResyncInitRequest, opts ...grpc.CallOption) (*IpRouteResyncInitResponse, error)
	// *
	// Ends the current route resync process.
	// All routes and vias not added or modified during the resync will be deleted.
	//
	// EosSdk reference: eos::ip_route_mgr::resync_complete
	ResyncComplete(ctx context.Context, in *IpRouteResyncCompleteRequest, opts ...grpc.CallOption) (*IpRouteResyncCompleteResponse, error)
	// *
	// Enumerates all configured static routes.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_iter
	IpRoutes(ctx context.Context, in *IpRoutesRequest, opts ...grpc.CallOption) (IpRouteMgrService_IpRoutesClient, error)
	// *
	// Enumerates all configured vias for a given route.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_via_iter
	IpRouteVias(ctx context.Context, in *IpRouteViasRequest, opts ...grpc.CallOption) (IpRouteMgrService_IpRouteViasClient, error)
	// *
	// Queries whether the given route is configured or not.
	//
	// EosSdk reference: eos::ip_route_mgr::exists
	IpRouteExists(ctx context.Context, in *IpRouteExistsRequest, opts ...grpc.CallOption) (*IpRouteExistsResponse, error)
	// *
	// Queries whether the given via exists for the given route.
	//
	// EosSdk reference: eos::ip_route_mgr::exists
	IpRouteViaExists(ctx context.Context, in *IpRouteViaExistsRequest, opts ...grpc.CallOption) (*IpRouteViaExistsResponse, error)
	// *
	// Queries the route for the given route key.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route
	IpRoute(ctx context.Context, in *IpRouteRequest, opts ...grpc.CallOption) (*IpRouteResponse, error)
	// *
	// Sets a static route.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_set
	IpRouteSet(ctx context.Context, in *IpRouteSetRequest, opts ...grpc.CallOption) (*IpRouteSetResponse, error)
	// *
	// Sets multiple routes at once for each given route key.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_set
	BulkIpRouteSet(ctx context.Context, in *BulkIpRouteSetRequest, opts ...grpc.CallOption) (*BulkIpRouteSetResponse, error)
	// *
	// Deletes a static route.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_del
	IpRouteDel(ctx context.Context, in *IpRouteDelRequest, opts ...grpc.CallOption) (*IpRouteDelResponse, error)
	// *
	// Deletes multiple static routes at once for each given route key.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_del
	BulkIpRouteDel(ctx context.Context, in *BulkIpRouteDelRequest, opts ...grpc.CallOption) (*BulkIpRouteDelResponse, error)
	// *
	// Sets the via for a given route key.
	// See EosSdk reference for more information.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_via_set
	IpRouteViaSet(ctx context.Context, in *IpRouteViaSetRequest, opts ...grpc.CallOption) (*IpRouteViaSetResponse, error)
	// *
	// Sets multiple vias at once for each given route key.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_via_set
	BulkIpRouteViaSet(ctx context.Context, in *BulkIpRouteViaSetRequest, opts ...grpc.CallOption) (*BulkIpRouteViaSetResponse, error)
	// *
	// Deletes the via for a given route key.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_via_delete
	IpRouteViaDel(ctx context.Context, in *IpRouteViaDelRequest, opts ...grpc.CallOption) (*IpRouteViaDelResponse, error)
	// *
	// Deletes multiple vias at once for each given route key.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_via_delete
	BulkIpRouteViaDel(ctx context.Context, in *BulkIpRouteViaDelRequest, opts ...grpc.CallOption) (*BulkIpRouteViaDelResponse, error)
}

type ipRouteMgrServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewIpRouteMgrServiceClient(cc grpc.ClientConnInterface) IpRouteMgrServiceClient {
	return &ipRouteMgrServiceClient{cc}
}

func (c *ipRouteMgrServiceClient) Tag(ctx context.Context, in *TagRequest, opts ...grpc.CallOption) (*TagResponse, error) {
	out := new(TagResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/tag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) TagIs(ctx context.Context, in *TagIsRequest, opts ...grpc.CallOption) (*TagIsResponse, error) {
	out := new(TagIsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/tag_is", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) ResyncInit(ctx context.Context, in *IpRouteResyncInitRequest, opts ...grpc.CallOption) (*IpRouteResyncInitResponse, error) {
	out := new(IpRouteResyncInitResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/resync_init", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) ResyncComplete(ctx context.Context, in *IpRouteResyncCompleteRequest, opts ...grpc.CallOption) (*IpRouteResyncCompleteResponse, error) {
	out := new(IpRouteResyncCompleteResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/resync_complete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) IpRoutes(ctx context.Context, in *IpRoutesRequest, opts ...grpc.CallOption) (IpRouteMgrService_IpRoutesClient, error) {
	stream, err := c.cc.NewStream(ctx, &IpRouteMgrService_ServiceDesc.Streams[0], "/eos.remote.IpRouteMgrService/ip_routes", opts...)
	if err != nil {
		return nil, err
	}
	x := &ipRouteMgrServiceIpRoutesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IpRouteMgrService_IpRoutesClient interface {
	Recv() (*IpRoutesResponse, error)
	grpc.ClientStream
}

type ipRouteMgrServiceIpRoutesClient struct {
	grpc.ClientStream
}

func (x *ipRouteMgrServiceIpRoutesClient) Recv() (*IpRoutesResponse, error) {
	m := new(IpRoutesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ipRouteMgrServiceClient) IpRouteVias(ctx context.Context, in *IpRouteViasRequest, opts ...grpc.CallOption) (IpRouteMgrService_IpRouteViasClient, error) {
	stream, err := c.cc.NewStream(ctx, &IpRouteMgrService_ServiceDesc.Streams[1], "/eos.remote.IpRouteMgrService/ip_route_vias", opts...)
	if err != nil {
		return nil, err
	}
	x := &ipRouteMgrServiceIpRouteViasClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type IpRouteMgrService_IpRouteViasClient interface {
	Recv() (*IpRouteViasResponse, error)
	grpc.ClientStream
}

type ipRouteMgrServiceIpRouteViasClient struct {
	grpc.ClientStream
}

func (x *ipRouteMgrServiceIpRouteViasClient) Recv() (*IpRouteViasResponse, error) {
	m := new(IpRouteViasResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ipRouteMgrServiceClient) IpRouteExists(ctx context.Context, in *IpRouteExistsRequest, opts ...grpc.CallOption) (*IpRouteExistsResponse, error) {
	out := new(IpRouteExistsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/ip_route_exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) IpRouteViaExists(ctx context.Context, in *IpRouteViaExistsRequest, opts ...grpc.CallOption) (*IpRouteViaExistsResponse, error) {
	out := new(IpRouteViaExistsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/ip_route_via_exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) IpRoute(ctx context.Context, in *IpRouteRequest, opts ...grpc.CallOption) (*IpRouteResponse, error) {
	out := new(IpRouteResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/ip_route", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) IpRouteSet(ctx context.Context, in *IpRouteSetRequest, opts ...grpc.CallOption) (*IpRouteSetResponse, error) {
	out := new(IpRouteSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/ip_route_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) BulkIpRouteSet(ctx context.Context, in *BulkIpRouteSetRequest, opts ...grpc.CallOption) (*BulkIpRouteSetResponse, error) {
	out := new(BulkIpRouteSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/bulk_ip_route_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) IpRouteDel(ctx context.Context, in *IpRouteDelRequest, opts ...grpc.CallOption) (*IpRouteDelResponse, error) {
	out := new(IpRouteDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/ip_route_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) BulkIpRouteDel(ctx context.Context, in *BulkIpRouteDelRequest, opts ...grpc.CallOption) (*BulkIpRouteDelResponse, error) {
	out := new(BulkIpRouteDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/bulk_ip_route_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) IpRouteViaSet(ctx context.Context, in *IpRouteViaSetRequest, opts ...grpc.CallOption) (*IpRouteViaSetResponse, error) {
	out := new(IpRouteViaSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/ip_route_via_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) BulkIpRouteViaSet(ctx context.Context, in *BulkIpRouteViaSetRequest, opts ...grpc.CallOption) (*BulkIpRouteViaSetResponse, error) {
	out := new(BulkIpRouteViaSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/bulk_ip_route_via_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) IpRouteViaDel(ctx context.Context, in *IpRouteViaDelRequest, opts ...grpc.CallOption) (*IpRouteViaDelResponse, error) {
	out := new(IpRouteViaDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/ip_route_via_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ipRouteMgrServiceClient) BulkIpRouteViaDel(ctx context.Context, in *BulkIpRouteViaDelRequest, opts ...grpc.CallOption) (*BulkIpRouteViaDelResponse, error) {
	out := new(BulkIpRouteViaDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.IpRouteMgrService/bulk_ip_route_via_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IpRouteMgrServiceServer is the server API for IpRouteMgrService service.
// All implementations should embed UnimplementedIpRouteMgrServiceServer
// for forward compatibility
type IpRouteMgrServiceServer interface {
	// *
	// Queries for the current tag assigned to the ip route manager.
	//
	// EosSdk reference: eos::ip_route_mgr::tag
	Tag(context.Context, *TagRequest) (*TagResponse, error)
	// *
	// Sets the current tag for the ip route manager.
	// This service will only interact with routes with the given tag.
	//
	// EosSdk reference: eos::ip_route_mgr::tag_is
	TagIs(context.Context, *TagIsRequest) (*TagIsResponse, error)
	// *
	// Starts the route resync process, to set the routes to a known state.
	// The resync_complete rpc, must be called to end the resync.
	// Please check the EosSdk reference for further details.
	//
	// EosSdk reference: eos::ip_route_mgr::resync_init
	ResyncInit(context.Context, *IpRouteResyncInitRequest) (*IpRouteResyncInitResponse, error)
	// *
	// Ends the current route resync process.
	// All routes and vias not added or modified during the resync will be deleted.
	//
	// EosSdk reference: eos::ip_route_mgr::resync_complete
	ResyncComplete(context.Context, *IpRouteResyncCompleteRequest) (*IpRouteResyncCompleteResponse, error)
	// *
	// Enumerates all configured static routes.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_iter
	IpRoutes(*IpRoutesRequest, IpRouteMgrService_IpRoutesServer) error
	// *
	// Enumerates all configured vias for a given route.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_via_iter
	IpRouteVias(*IpRouteViasRequest, IpRouteMgrService_IpRouteViasServer) error
	// *
	// Queries whether the given route is configured or not.
	//
	// EosSdk reference: eos::ip_route_mgr::exists
	IpRouteExists(context.Context, *IpRouteExistsRequest) (*IpRouteExistsResponse, error)
	// *
	// Queries whether the given via exists for the given route.
	//
	// EosSdk reference: eos::ip_route_mgr::exists
	IpRouteViaExists(context.Context, *IpRouteViaExistsRequest) (*IpRouteViaExistsResponse, error)
	// *
	// Queries the route for the given route key.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route
	IpRoute(context.Context, *IpRouteRequest) (*IpRouteResponse, error)
	// *
	// Sets a static route.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_set
	IpRouteSet(context.Context, *IpRouteSetRequest) (*IpRouteSetResponse, error)
	// *
	// Sets multiple routes at once for each given route key.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_set
	BulkIpRouteSet(context.Context, *BulkIpRouteSetRequest) (*BulkIpRouteSetResponse, error)
	// *
	// Deletes a static route.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_del
	IpRouteDel(context.Context, *IpRouteDelRequest) (*IpRouteDelResponse, error)
	// *
	// Deletes multiple static routes at once for each given route key.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_del
	BulkIpRouteDel(context.Context, *BulkIpRouteDelRequest) (*BulkIpRouteDelResponse, error)
	// *
	// Sets the via for a given route key.
	// See EosSdk reference for more information.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_via_set
	IpRouteViaSet(context.Context, *IpRouteViaSetRequest) (*IpRouteViaSetResponse, error)
	// *
	// Sets multiple vias at once for each given route key.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_via_set
	BulkIpRouteViaSet(context.Context, *BulkIpRouteViaSetRequest) (*BulkIpRouteViaSetResponse, error)
	// *
	// Deletes the via for a given route key.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_via_delete
	IpRouteViaDel(context.Context, *IpRouteViaDelRequest) (*IpRouteViaDelResponse, error)
	// *
	// Deletes multiple vias at once for each given route key.
	//
	// EosSdk reference: eos::ip_route_mgr::ip_route_via_delete
	BulkIpRouteViaDel(context.Context, *BulkIpRouteViaDelRequest) (*BulkIpRouteViaDelResponse, error)
}

// UnimplementedIpRouteMgrServiceServer should be embedded to have forward compatible implementations.
type UnimplementedIpRouteMgrServiceServer struct {
}

func (UnimplementedIpRouteMgrServiceServer) Tag(context.Context, *TagRequest) (*TagResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Tag not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) TagIs(context.Context, *TagIsRequest) (*TagIsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TagIs not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) ResyncInit(context.Context, *IpRouteResyncInitRequest) (*IpRouteResyncInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResyncInit not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) ResyncComplete(context.Context, *IpRouteResyncCompleteRequest) (*IpRouteResyncCompleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResyncComplete not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) IpRoutes(*IpRoutesRequest, IpRouteMgrService_IpRoutesServer) error {
	return status.Errorf(codes.Unimplemented, "method IpRoutes not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) IpRouteVias(*IpRouteViasRequest, IpRouteMgrService_IpRouteViasServer) error {
	return status.Errorf(codes.Unimplemented, "method IpRouteVias not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) IpRouteExists(context.Context, *IpRouteExistsRequest) (*IpRouteExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpRouteExists not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) IpRouteViaExists(context.Context, *IpRouteViaExistsRequest) (*IpRouteViaExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpRouteViaExists not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) IpRoute(context.Context, *IpRouteRequest) (*IpRouteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpRoute not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) IpRouteSet(context.Context, *IpRouteSetRequest) (*IpRouteSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpRouteSet not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) BulkIpRouteSet(context.Context, *BulkIpRouteSetRequest) (*BulkIpRouteSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkIpRouteSet not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) IpRouteDel(context.Context, *IpRouteDelRequest) (*IpRouteDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpRouteDel not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) BulkIpRouteDel(context.Context, *BulkIpRouteDelRequest) (*BulkIpRouteDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkIpRouteDel not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) IpRouteViaSet(context.Context, *IpRouteViaSetRequest) (*IpRouteViaSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpRouteViaSet not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) BulkIpRouteViaSet(context.Context, *BulkIpRouteViaSetRequest) (*BulkIpRouteViaSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkIpRouteViaSet not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) IpRouteViaDel(context.Context, *IpRouteViaDelRequest) (*IpRouteViaDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IpRouteViaDel not implemented")
}
func (UnimplementedIpRouteMgrServiceServer) BulkIpRouteViaDel(context.Context, *BulkIpRouteViaDelRequest) (*BulkIpRouteViaDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkIpRouteViaDel not implemented")
}

// UnsafeIpRouteMgrServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IpRouteMgrServiceServer will
// result in compilation errors.
type UnsafeIpRouteMgrServiceServer interface {
	mustEmbedUnimplementedIpRouteMgrServiceServer()
}

func RegisterIpRouteMgrServiceServer(s grpc.ServiceRegistrar, srv IpRouteMgrServiceServer) {
	s.RegisterService(&IpRouteMgrService_ServiceDesc, srv)
}

func _IpRouteMgrService_Tag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).Tag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/tag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).Tag(ctx, req.(*TagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_TagIs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagIsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).TagIs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/tag_is",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).TagIs(ctx, req.(*TagIsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_ResyncInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpRouteResyncInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).ResyncInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/resync_init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).ResyncInit(ctx, req.(*IpRouteResyncInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_ResyncComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpRouteResyncCompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).ResyncComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/resync_complete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).ResyncComplete(ctx, req.(*IpRouteResyncCompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_IpRoutes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IpRoutesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IpRouteMgrServiceServer).IpRoutes(m, &ipRouteMgrServiceIpRoutesServer{stream})
}

type IpRouteMgrService_IpRoutesServer interface {
	Send(*IpRoutesResponse) error
	grpc.ServerStream
}

type ipRouteMgrServiceIpRoutesServer struct {
	grpc.ServerStream
}

func (x *ipRouteMgrServiceIpRoutesServer) Send(m *IpRoutesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _IpRouteMgrService_IpRouteVias_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(IpRouteViasRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IpRouteMgrServiceServer).IpRouteVias(m, &ipRouteMgrServiceIpRouteViasServer{stream})
}

type IpRouteMgrService_IpRouteViasServer interface {
	Send(*IpRouteViasResponse) error
	grpc.ServerStream
}

type ipRouteMgrServiceIpRouteViasServer struct {
	grpc.ServerStream
}

func (x *ipRouteMgrServiceIpRouteViasServer) Send(m *IpRouteViasResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _IpRouteMgrService_IpRouteExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpRouteExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).IpRouteExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/ip_route_exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).IpRouteExists(ctx, req.(*IpRouteExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_IpRouteViaExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpRouteViaExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).IpRouteViaExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/ip_route_via_exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).IpRouteViaExists(ctx, req.(*IpRouteViaExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_IpRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).IpRoute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/ip_route",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).IpRoute(ctx, req.(*IpRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_IpRouteSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpRouteSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).IpRouteSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/ip_route_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).IpRouteSet(ctx, req.(*IpRouteSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_BulkIpRouteSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkIpRouteSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).BulkIpRouteSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/bulk_ip_route_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).BulkIpRouteSet(ctx, req.(*BulkIpRouteSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_IpRouteDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpRouteDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).IpRouteDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/ip_route_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).IpRouteDel(ctx, req.(*IpRouteDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_BulkIpRouteDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkIpRouteDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).BulkIpRouteDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/bulk_ip_route_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).BulkIpRouteDel(ctx, req.(*BulkIpRouteDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_IpRouteViaSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpRouteViaSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).IpRouteViaSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/ip_route_via_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).IpRouteViaSet(ctx, req.(*IpRouteViaSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_BulkIpRouteViaSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkIpRouteViaSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).BulkIpRouteViaSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/bulk_ip_route_via_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).BulkIpRouteViaSet(ctx, req.(*BulkIpRouteViaSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_IpRouteViaDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IpRouteViaDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).IpRouteViaDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/ip_route_via_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).IpRouteViaDel(ctx, req.(*IpRouteViaDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IpRouteMgrService_BulkIpRouteViaDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkIpRouteViaDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IpRouteMgrServiceServer).BulkIpRouteViaDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.IpRouteMgrService/bulk_ip_route_via_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IpRouteMgrServiceServer).BulkIpRouteViaDel(ctx, req.(*BulkIpRouteViaDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// IpRouteMgrService_ServiceDesc is the grpc.ServiceDesc for IpRouteMgrService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var IpRouteMgrService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eos.remote.IpRouteMgrService",
	HandlerType: (*IpRouteMgrServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "tag",
			Handler:    _IpRouteMgrService_Tag_Handler,
		},
		{
			MethodName: "tag_is",
			Handler:    _IpRouteMgrService_TagIs_Handler,
		},
		{
			MethodName: "resync_init",
			Handler:    _IpRouteMgrService_ResyncInit_Handler,
		},
		{
			MethodName: "resync_complete",
			Handler:    _IpRouteMgrService_ResyncComplete_Handler,
		},
		{
			MethodName: "ip_route_exists",
			Handler:    _IpRouteMgrService_IpRouteExists_Handler,
		},
		{
			MethodName: "ip_route_via_exists",
			Handler:    _IpRouteMgrService_IpRouteViaExists_Handler,
		},
		{
			MethodName: "ip_route",
			Handler:    _IpRouteMgrService_IpRoute_Handler,
		},
		{
			MethodName: "ip_route_set",
			Handler:    _IpRouteMgrService_IpRouteSet_Handler,
		},
		{
			MethodName: "bulk_ip_route_set",
			Handler:    _IpRouteMgrService_BulkIpRouteSet_Handler,
		},
		{
			MethodName: "ip_route_del",
			Handler:    _IpRouteMgrService_IpRouteDel_Handler,
		},
		{
			MethodName: "bulk_ip_route_del",
			Handler:    _IpRouteMgrService_BulkIpRouteDel_Handler,
		},
		{
			MethodName: "ip_route_via_set",
			Handler:    _IpRouteMgrService_IpRouteViaSet_Handler,
		},
		{
			MethodName: "bulk_ip_route_via_set",
			Handler:    _IpRouteMgrService_BulkIpRouteViaSet_Handler,
		},
		{
			MethodName: "ip_route_via_del",
			Handler:    _IpRouteMgrService_IpRouteViaDel_Handler,
		},
		{
			MethodName: "bulk_ip_route_via_del",
			Handler:    _IpRouteMgrService_BulkIpRouteViaDel_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ip_routes",
			Handler:       _IpRouteMgrService_IpRoutes_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ip_route_vias",
			Handler:       _IpRouteMgrService_IpRouteVias_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ip_route.proto",
}
