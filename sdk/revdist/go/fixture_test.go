package revdist

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"strconv"
	"testing"
	"unsafe"

	"github.com/gagliardetto/solana-go"
)

// These tests deserialize binary fixtures generated by the Rust fixture
// generator (testdata/generate-fixtures) and verify that Go's deserialized
// field values match the expected values from the JSON sidecar files.
//
// The fixtures are authoritative because they are produced by bytemuck::bytes_of
// on real Rust struct instances â€” the byte layout comes from the Rust compiler's
// #[repr(C)] layout, not from hand-coded offsets.
//
// Regenerate fixtures:
//   cd ../testdata/fixtures/generate-fixtures && cargo run

type fixtureMeta struct {
	Name             string       `json:"name"`
	StructSize       int          `json:"struct_size"`
	DiscriminatorHex string       `json:"discriminator_hex"`
	Fields           []fieldValue `json:"fields"`
}

type fieldValue struct {
	Name  string `json:"name"`
	Value string `json:"value"`
	Type  string `json:"typ"`
}

func fixturesDir() string {
	_, filename, _, _ := runtime.Caller(0)
	return filepath.Join(filepath.Dir(filename), "..", "testdata", "fixtures")
}

func loadFixture(t *testing.T, name string) ([]byte, fixtureMeta) {
	t.Helper()
	dir := fixturesDir()

	binData, err := os.ReadFile(filepath.Join(dir, name+".bin"))
	if err != nil {
		t.Fatalf("reading %s.bin: %v", name, err)
	}

	jsonData, err := os.ReadFile(filepath.Join(dir, name+".json"))
	if err != nil {
		t.Fatalf("reading %s.json: %v", name, err)
	}

	var meta fixtureMeta
	if err := json.Unmarshal(jsonData, &meta); err != nil {
		t.Fatalf("parsing %s.json: %v", name, err)
	}

	return binData, meta
}

func TestFixtureProgramConfig(t *testing.T) {
	data, meta := loadFixture(t, "program_config")

	if got := int(unsafe.Sizeof(ProgramConfig{})); got != meta.StructSize {
		t.Fatalf("sizeof(ProgramConfig) = %d, Rust says %d", got, meta.StructSize)
	}

	config, err := deserializeAccount[ProgramConfig](data, DiscriminatorProgramConfig)
	if err != nil {
		t.Fatalf("deserializing: %v", err)
	}

	assertFields(t, meta.Fields, map[string]any{
		"Flags":                                 config.Flags,
		"NextCompletedDZEpoch":                  config.NextCompletedDZEpoch,
		"BumpSeed":                              config.BumpSeed,
		"AdminKey":                              config.AdminKey,
		"DebtAccountantKey":                     config.DebtAccountantKey,
		"RewardsAccountantKey":                  config.RewardsAccountantKey,
		"ContributorManagerKey":                 config.ContributorManagerKey,
		"SOL2ZSwapProgramID":                    config.SOL2ZSwapProgramID,
		"CalculationGracePeriodMinutes":         config.DistributionParameters.CalculationGracePeriodMinutes,
		"InitializationGracePeriodMinutes":      config.DistributionParameters.InitializationGracePeriodMinutes,
		"MinimumEpochDurationToFinalizeRewards": config.DistributionParameters.MinimumEpochDurationToFinalizeRewards,
		"BurnRateLimit":                         config.DistributionParameters.CommunityBurnRateParameters.Limit,
		"BurnRateDZEpochsToIncreasing":          config.DistributionParameters.CommunityBurnRateParameters.DZEpochsToIncreasing,
		"BurnRateDZEpochsToLimit":               config.DistributionParameters.CommunityBurnRateParameters.DZEpochsToLimit,
		"BaseBlockRewardsPct":                   config.DistributionParameters.SolanaValidatorFeeParameters.BaseBlockRewardsPct,
		"PriorityBlockRewardsPct":               config.DistributionParameters.SolanaValidatorFeeParameters.PriorityBlockRewardsPct,
		"InflationRewardsPct":                   config.DistributionParameters.SolanaValidatorFeeParameters.InflationRewardsPct,
		"JitoTipsPct":                           config.DistributionParameters.SolanaValidatorFeeParameters.JitoTipsPct,
		"FixedSOLAmount":                        config.DistributionParameters.SolanaValidatorFeeParameters.FixedSOLAmount,
		"DistributeRewardsLamports":             config.RelayParameters.DistributeRewardsLamports,
		"DebtWriteOffFeatureActivationEpoch":    config.DebtWriteOffFeatureActivationEpoch,
	})
}

func TestFixtureDistribution(t *testing.T) {
	data, meta := loadFixture(t, "distribution")

	if got := int(unsafe.Sizeof(Distribution{})); got != meta.StructSize {
		t.Fatalf("sizeof(Distribution) = %d, Rust says %d", got, meta.StructSize)
	}

	dist, err := deserializeAccount[Distribution](data, DiscriminatorDistribution)
	if err != nil {
		t.Fatalf("deserializing: %v", err)
	}

	assertFields(t, meta.Fields, map[string]any{
		"DZEpoch":                          dist.DZEpoch,
		"Flags":                            dist.Flags,
		"CommunityBurnRate":                dist.CommunityBurnRate,
		"BaseBlockRewardsPct":              dist.SolanaValidatorFeeParameters.BaseBlockRewardsPct,
		"PriorityBlockRewardsPct":          dist.SolanaValidatorFeeParameters.PriorityBlockRewardsPct,
		"InflationRewardsPct":              dist.SolanaValidatorFeeParameters.InflationRewardsPct,
		"JitoTipsPct":                      dist.SolanaValidatorFeeParameters.JitoTipsPct,
		"FixedSOLAmount":                   dist.SolanaValidatorFeeParameters.FixedSOLAmount,
		"TotalSolanaValidators":            dist.TotalSolanaValidators,
		"SolanaValidatorPaymentsCount":     dist.SolanaValidatorPaymentsCount,
		"TotalSolanaValidatorDebt":         dist.TotalSolanaValidatorDebt,
		"CollectedSolanaValidatorPayments": dist.CollectedSolanaValidatorPayments,
		"TotalContributors":                dist.TotalContributors,
		"DistributedRewardsCount":          dist.DistributedRewardsCount,
		"CollectedPrepaid2ZPayments":       dist.CollectedPrepaid2ZPayments,
		"Collected2ZConvertedFromSOL":      dist.Collected2ZConvertedFromSOL,
		"UncollectibleSOLDebt":             dist.UncollectibleSOLDebt,
		"Distributed2ZAmount":              dist.Distributed2ZAmount,
		"Burned2ZAmount":                   dist.Burned2ZAmount,
		"SolanaValidatorWriteOffCount":     dist.SolanaValidatorWriteOffCount,
	})
}

func TestFixtureJournal(t *testing.T) {
	data, meta := loadFixture(t, "journal")

	if got := int(unsafe.Sizeof(Journal{})); got != meta.StructSize {
		t.Fatalf("sizeof(Journal) = %d, Rust says %d", got, meta.StructSize)
	}

	journal, err := deserializeAccount[Journal](data, DiscriminatorJournal)
	if err != nil {
		t.Fatalf("deserializing: %v", err)
	}

	assertFields(t, meta.Fields, map[string]any{
		"BumpSeed":                 journal.BumpSeed,
		"TotalSOLBalance":          journal.TotalSOLBalance,
		"Total2ZBalance":           journal.Total2ZBalance,
		"Swap2ZDestinationBalance": journal.Swap2ZDestinationBalance,
		"SwappedSOLAmount":         journal.SwappedSOLAmount,
		"NextDZEpochToSweepTokens": journal.NextDZEpochToSweepTokens,
	})
}

func TestFixtureSolanaValidatorDeposit(t *testing.T) {
	data, meta := loadFixture(t, "solana_validator_deposit")

	if got := int(unsafe.Sizeof(SolanaValidatorDeposit{})); got != meta.StructSize {
		t.Fatalf("sizeof(SolanaValidatorDeposit) = %d, Rust says %d", got, meta.StructSize)
	}

	deposit, err := deserializeAccount[SolanaValidatorDeposit](data, DiscriminatorSolanaValidatorDeposit)
	if err != nil {
		t.Fatalf("deserializing: %v", err)
	}

	assertFields(t, meta.Fields, map[string]any{
		"NodeID":            deposit.NodeID,
		"WrittenOffSOLDebt": deposit.WrittenOffSOLDebt,
	})
}

func TestFixtureContributorRewards(t *testing.T) {
	data, meta := loadFixture(t, "contributor_rewards")

	if got := int(unsafe.Sizeof(ContributorRewards{})); got != meta.StructSize {
		t.Fatalf("sizeof(ContributorRewards) = %d, Rust says %d", got, meta.StructSize)
	}

	rewards, err := deserializeAccount[ContributorRewards](data, DiscriminatorContributorRewards)
	if err != nil {
		t.Fatalf("deserializing: %v", err)
	}

	assertFields(t, meta.Fields, map[string]any{
		"RewardsManagerKey": rewards.RewardsManagerKey,
		"ServiceKey":        rewards.ServiceKey,
		"Flags":             rewards.Flags,
	})
}

// assertFields checks each expected field from the JSON metadata against the
// deserialized Go value.
func assertFields(t *testing.T, expected []fieldValue, got map[string]any) {
	t.Helper()
	for _, f := range expected {
		val, ok := got[f.Name]
		if !ok {
			t.Errorf("field %s: not found in Go struct map", f.Name)
			continue
		}
		assertField(t, f, val)
	}
}

func assertField(t *testing.T, f fieldValue, got any) {
	t.Helper()
	switch f.Type {
	case "u8":
		want, _ := strconv.ParseUint(f.Value, 10, 8)
		assertEq(t, f.Name, uint8(want), got)
	case "u16":
		want, _ := strconv.ParseUint(f.Value, 10, 16)
		assertEq(t, f.Name, uint16(want), got)
	case "u32":
		want, _ := strconv.ParseUint(f.Value, 10, 32)
		assertEq(t, f.Name, uint32(want), got)
	case "u64":
		want, _ := strconv.ParseUint(f.Value, 10, 64)
		assertEq(t, f.Name, uint64(want), got)
	case "pubkey":
		want := solana.MustPublicKeyFromBase58(f.Value)
		assertEq(t, f.Name, want, got)
	default:
		t.Errorf("field %s: unknown type %q", f.Name, f.Type)
	}
}

func assertEq(t *testing.T, name string, want, got any) {
	t.Helper()
	if !reflect.DeepEqual(want, got) {
		t.Errorf("%s: want %v, got %v", name, want, fmt.Sprintf("%v", got))
	}
}
