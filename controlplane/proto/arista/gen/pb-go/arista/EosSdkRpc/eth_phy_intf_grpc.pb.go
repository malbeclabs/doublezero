// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.6
// source: eth_phy_intf.proto

package EosSdkRpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// EthPhyIntfMgrServiceClient is the client API for EthPhyIntfMgrService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EthPhyIntfMgrServiceClient interface {
	// *
	// Subscription to monitor interface events. This request
	// stays active until the client cancels or the server shuts down.
	// When all = false and no version is specified, this request has no effect.
	//
	// EOS SDK reference:: eos::eth_phy_intf_handler (class)
	Watch(ctx context.Context, in *EthPhyIntfWatchRequest, opts ...grpc.CallOption) (EthPhyIntfMgrService_WatchClient, error)
	// *
	// Returns the list of interfaces.
	//
	// EOS SDK reference:: eos::eth_phy_intf_mgr::eth_phy_intf_iter
	EthPhyIntfs(ctx context.Context, in *EthPhyIntfsRequest, opts ...grpc.CallOption) (EthPhyIntfMgrService_EthPhyIntfsClient, error)
	// *
	// Returns whether the given physical ethernet interface exists.
	//
	// If exists returns true, then this intf_id_t can be successfully
	// passed into every method of the eth_intf_mgr. If not, then
	// methods of the eth_intf_mgr can throw a no_such_interface_error
	// exception.
	//
	// The exists method of all *intf_mgr classes that manage a given
	// interface (ie intf_mgr, eth_intf_mgr, and eth_phy_intf_mgr for
	// physical interfaces) are all guaranteed to return the same
	// result.
	//
	// EOS SDK reference: : eos::eth_phy_intf_mgr::exists
	Exists(ctx context.Context, in *EthPhyIntfExistsRequest, opts ...grpc.CallOption) (*EthPhyIntfExistsResponse, error)
	// *
	// Returns whether the underlying hardware for this interface is present.
	//
	// EOS SDK reference:: eos::eth_phy_intf_mgr::hardware_present
	HardwarePresent(ctx context.Context, in *EthPhyIntfHardwarePresentRequest, opts ...grpc.CallOption) (*EthPhyIntfHardwarePresentResponse, error)
	// *
	// Returns the "burned in" address of the interface.
	//
	// EOS SDK reference:: eos::eth_phy_intf_mgr::burned_in_eth_addr
	BurnedInEthAddr(ctx context.Context, in *EthPhyIntfBurnedInEthAddrRequest, opts ...grpc.CallOption) (*EthPhyIntfBurnedInEthAddrResponse, error)
	// *
	// Returns the operational link speed.
	//
	// EOS SDK reference:: eos::eth_phy_intf_mgr::link_speed
	LinkSpeed(ctx context.Context, in *EthPhyIntfLinkSpeedRequest, opts ...grpc.CallOption) (*EthPhyIntfLinkSpeedResponse, error)
	// *
	// Returns the presence of transceiver for the given interface
	//
	// EOS SDK reference:: eos::eth_phy_intf_mgr::transceiver_present
	TransceiverPresent(ctx context.Context, in *EthPhyIntfTransceiverPresentRequest, opts ...grpc.CallOption) (*EthPhyIntfTransceiverPresentResponse, error)
}

type ethPhyIntfMgrServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEthPhyIntfMgrServiceClient(cc grpc.ClientConnInterface) EthPhyIntfMgrServiceClient {
	return &ethPhyIntfMgrServiceClient{cc}
}

func (c *ethPhyIntfMgrServiceClient) Watch(ctx context.Context, in *EthPhyIntfWatchRequest, opts ...grpc.CallOption) (EthPhyIntfMgrService_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &EthPhyIntfMgrService_ServiceDesc.Streams[0], "/eos.remote.EthPhyIntfMgrService/watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &ethPhyIntfMgrServiceWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EthPhyIntfMgrService_WatchClient interface {
	Recv() (*EthPhyIntfWatchResponse, error)
	grpc.ClientStream
}

type ethPhyIntfMgrServiceWatchClient struct {
	grpc.ClientStream
}

func (x *ethPhyIntfMgrServiceWatchClient) Recv() (*EthPhyIntfWatchResponse, error) {
	m := new(EthPhyIntfWatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ethPhyIntfMgrServiceClient) EthPhyIntfs(ctx context.Context, in *EthPhyIntfsRequest, opts ...grpc.CallOption) (EthPhyIntfMgrService_EthPhyIntfsClient, error) {
	stream, err := c.cc.NewStream(ctx, &EthPhyIntfMgrService_ServiceDesc.Streams[1], "/eos.remote.EthPhyIntfMgrService/eth_phy_intfs", opts...)
	if err != nil {
		return nil, err
	}
	x := &ethPhyIntfMgrServiceEthPhyIntfsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EthPhyIntfMgrService_EthPhyIntfsClient interface {
	Recv() (*EthPhyIntfsResponse, error)
	grpc.ClientStream
}

type ethPhyIntfMgrServiceEthPhyIntfsClient struct {
	grpc.ClientStream
}

func (x *ethPhyIntfMgrServiceEthPhyIntfsClient) Recv() (*EthPhyIntfsResponse, error) {
	m := new(EthPhyIntfsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ethPhyIntfMgrServiceClient) Exists(ctx context.Context, in *EthPhyIntfExistsRequest, opts ...grpc.CallOption) (*EthPhyIntfExistsResponse, error) {
	out := new(EthPhyIntfExistsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.EthPhyIntfMgrService/exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethPhyIntfMgrServiceClient) HardwarePresent(ctx context.Context, in *EthPhyIntfHardwarePresentRequest, opts ...grpc.CallOption) (*EthPhyIntfHardwarePresentResponse, error) {
	out := new(EthPhyIntfHardwarePresentResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.EthPhyIntfMgrService/hardware_present", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethPhyIntfMgrServiceClient) BurnedInEthAddr(ctx context.Context, in *EthPhyIntfBurnedInEthAddrRequest, opts ...grpc.CallOption) (*EthPhyIntfBurnedInEthAddrResponse, error) {
	out := new(EthPhyIntfBurnedInEthAddrResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.EthPhyIntfMgrService/burned_in_eth_addr", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethPhyIntfMgrServiceClient) LinkSpeed(ctx context.Context, in *EthPhyIntfLinkSpeedRequest, opts ...grpc.CallOption) (*EthPhyIntfLinkSpeedResponse, error) {
	out := new(EthPhyIntfLinkSpeedResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.EthPhyIntfMgrService/link_speed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethPhyIntfMgrServiceClient) TransceiverPresent(ctx context.Context, in *EthPhyIntfTransceiverPresentRequest, opts ...grpc.CallOption) (*EthPhyIntfTransceiverPresentResponse, error) {
	out := new(EthPhyIntfTransceiverPresentResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.EthPhyIntfMgrService/transceiver_present", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EthPhyIntfMgrServiceServer is the server API for EthPhyIntfMgrService service.
// All implementations should embed UnimplementedEthPhyIntfMgrServiceServer
// for forward compatibility
type EthPhyIntfMgrServiceServer interface {
	// *
	// Subscription to monitor interface events. This request
	// stays active until the client cancels or the server shuts down.
	// When all = false and no version is specified, this request has no effect.
	//
	// EOS SDK reference:: eos::eth_phy_intf_handler (class)
	Watch(*EthPhyIntfWatchRequest, EthPhyIntfMgrService_WatchServer) error
	// *
	// Returns the list of interfaces.
	//
	// EOS SDK reference:: eos::eth_phy_intf_mgr::eth_phy_intf_iter
	EthPhyIntfs(*EthPhyIntfsRequest, EthPhyIntfMgrService_EthPhyIntfsServer) error
	// *
	// Returns whether the given physical ethernet interface exists.
	//
	// If exists returns true, then this intf_id_t can be successfully
	// passed into every method of the eth_intf_mgr. If not, then
	// methods of the eth_intf_mgr can throw a no_such_interface_error
	// exception.
	//
	// The exists method of all *intf_mgr classes that manage a given
	// interface (ie intf_mgr, eth_intf_mgr, and eth_phy_intf_mgr for
	// physical interfaces) are all guaranteed to return the same
	// result.
	//
	// EOS SDK reference: : eos::eth_phy_intf_mgr::exists
	Exists(context.Context, *EthPhyIntfExistsRequest) (*EthPhyIntfExistsResponse, error)
	// *
	// Returns whether the underlying hardware for this interface is present.
	//
	// EOS SDK reference:: eos::eth_phy_intf_mgr::hardware_present
	HardwarePresent(context.Context, *EthPhyIntfHardwarePresentRequest) (*EthPhyIntfHardwarePresentResponse, error)
	// *
	// Returns the "burned in" address of the interface.
	//
	// EOS SDK reference:: eos::eth_phy_intf_mgr::burned_in_eth_addr
	BurnedInEthAddr(context.Context, *EthPhyIntfBurnedInEthAddrRequest) (*EthPhyIntfBurnedInEthAddrResponse, error)
	// *
	// Returns the operational link speed.
	//
	// EOS SDK reference:: eos::eth_phy_intf_mgr::link_speed
	LinkSpeed(context.Context, *EthPhyIntfLinkSpeedRequest) (*EthPhyIntfLinkSpeedResponse, error)
	// *
	// Returns the presence of transceiver for the given interface
	//
	// EOS SDK reference:: eos::eth_phy_intf_mgr::transceiver_present
	TransceiverPresent(context.Context, *EthPhyIntfTransceiverPresentRequest) (*EthPhyIntfTransceiverPresentResponse, error)
}

// UnimplementedEthPhyIntfMgrServiceServer should be embedded to have forward compatible implementations.
type UnimplementedEthPhyIntfMgrServiceServer struct {
}

func (UnimplementedEthPhyIntfMgrServiceServer) Watch(*EthPhyIntfWatchRequest, EthPhyIntfMgrService_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedEthPhyIntfMgrServiceServer) EthPhyIntfs(*EthPhyIntfsRequest, EthPhyIntfMgrService_EthPhyIntfsServer) error {
	return status.Errorf(codes.Unimplemented, "method EthPhyIntfs not implemented")
}
func (UnimplementedEthPhyIntfMgrServiceServer) Exists(context.Context, *EthPhyIntfExistsRequest) (*EthPhyIntfExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exists not implemented")
}
func (UnimplementedEthPhyIntfMgrServiceServer) HardwarePresent(context.Context, *EthPhyIntfHardwarePresentRequest) (*EthPhyIntfHardwarePresentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HardwarePresent not implemented")
}
func (UnimplementedEthPhyIntfMgrServiceServer) BurnedInEthAddr(context.Context, *EthPhyIntfBurnedInEthAddrRequest) (*EthPhyIntfBurnedInEthAddrResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnedInEthAddr not implemented")
}
func (UnimplementedEthPhyIntfMgrServiceServer) LinkSpeed(context.Context, *EthPhyIntfLinkSpeedRequest) (*EthPhyIntfLinkSpeedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LinkSpeed not implemented")
}
func (UnimplementedEthPhyIntfMgrServiceServer) TransceiverPresent(context.Context, *EthPhyIntfTransceiverPresentRequest) (*EthPhyIntfTransceiverPresentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransceiverPresent not implemented")
}

// UnsafeEthPhyIntfMgrServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EthPhyIntfMgrServiceServer will
// result in compilation errors.
type UnsafeEthPhyIntfMgrServiceServer interface {
	mustEmbedUnimplementedEthPhyIntfMgrServiceServer()
}

func RegisterEthPhyIntfMgrServiceServer(s grpc.ServiceRegistrar, srv EthPhyIntfMgrServiceServer) {
	s.RegisterService(&EthPhyIntfMgrService_ServiceDesc, srv)
}

func _EthPhyIntfMgrService_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EthPhyIntfWatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EthPhyIntfMgrServiceServer).Watch(m, &ethPhyIntfMgrServiceWatchServer{stream})
}

type EthPhyIntfMgrService_WatchServer interface {
	Send(*EthPhyIntfWatchResponse) error
	grpc.ServerStream
}

type ethPhyIntfMgrServiceWatchServer struct {
	grpc.ServerStream
}

func (x *ethPhyIntfMgrServiceWatchServer) Send(m *EthPhyIntfWatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _EthPhyIntfMgrService_EthPhyIntfs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EthPhyIntfsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EthPhyIntfMgrServiceServer).EthPhyIntfs(m, &ethPhyIntfMgrServiceEthPhyIntfsServer{stream})
}

type EthPhyIntfMgrService_EthPhyIntfsServer interface {
	Send(*EthPhyIntfsResponse) error
	grpc.ServerStream
}

type ethPhyIntfMgrServiceEthPhyIntfsServer struct {
	grpc.ServerStream
}

func (x *ethPhyIntfMgrServiceEthPhyIntfsServer) Send(m *EthPhyIntfsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _EthPhyIntfMgrService_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EthPhyIntfExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthPhyIntfMgrServiceServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.EthPhyIntfMgrService/exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthPhyIntfMgrServiceServer).Exists(ctx, req.(*EthPhyIntfExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EthPhyIntfMgrService_HardwarePresent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EthPhyIntfHardwarePresentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthPhyIntfMgrServiceServer).HardwarePresent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.EthPhyIntfMgrService/hardware_present",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthPhyIntfMgrServiceServer).HardwarePresent(ctx, req.(*EthPhyIntfHardwarePresentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EthPhyIntfMgrService_BurnedInEthAddr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EthPhyIntfBurnedInEthAddrRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthPhyIntfMgrServiceServer).BurnedInEthAddr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.EthPhyIntfMgrService/burned_in_eth_addr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthPhyIntfMgrServiceServer).BurnedInEthAddr(ctx, req.(*EthPhyIntfBurnedInEthAddrRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EthPhyIntfMgrService_LinkSpeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EthPhyIntfLinkSpeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthPhyIntfMgrServiceServer).LinkSpeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.EthPhyIntfMgrService/link_speed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthPhyIntfMgrServiceServer).LinkSpeed(ctx, req.(*EthPhyIntfLinkSpeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EthPhyIntfMgrService_TransceiverPresent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EthPhyIntfTransceiverPresentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthPhyIntfMgrServiceServer).TransceiverPresent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.EthPhyIntfMgrService/transceiver_present",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthPhyIntfMgrServiceServer).TransceiverPresent(ctx, req.(*EthPhyIntfTransceiverPresentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EthPhyIntfMgrService_ServiceDesc is the grpc.ServiceDesc for EthPhyIntfMgrService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EthPhyIntfMgrService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eos.remote.EthPhyIntfMgrService",
	HandlerType: (*EthPhyIntfMgrServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "exists",
			Handler:    _EthPhyIntfMgrService_Exists_Handler,
		},
		{
			MethodName: "hardware_present",
			Handler:    _EthPhyIntfMgrService_HardwarePresent_Handler,
		},
		{
			MethodName: "burned_in_eth_addr",
			Handler:    _EthPhyIntfMgrService_BurnedInEthAddr_Handler,
		},
		{
			MethodName: "link_speed",
			Handler:    _EthPhyIntfMgrService_LinkSpeed_Handler,
		},
		{
			MethodName: "transceiver_present",
			Handler:    _EthPhyIntfMgrService_TransceiverPresent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "watch",
			Handler:       _EthPhyIntfMgrService_Watch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "eth_phy_intfs",
			Handler:       _EthPhyIntfMgrService_EthPhyIntfs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "eth_phy_intf.proto",
}

// EthPhyIntfCountersMgrServiceClient is the client API for EthPhyIntfCountersMgrService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EthPhyIntfCountersMgrServiceClient interface {
	// *
	// Gets the current counters of the given ethernet interface.
	//
	// EOS SDK reference: eos::eth_phy_intf_counter_mgr::counters
	Counters(ctx context.Context, in *EthPhyIntfCountersRequest, opts ...grpc.CallOption) (*EthPhyIntfCountersResponse, error)
	// *
	// Gets the current bin counters of the given ethernet interface.
	//
	// EOS SDK reference: eos::eth_phy_intf_counter_mgr::bin_counters
	BinCounters(ctx context.Context, in *EthPhyIntfBinCountersRequest, opts ...grpc.CallOption) (*EthPhyIntfBinCountersResponse, error)
}

type ethPhyIntfCountersMgrServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEthPhyIntfCountersMgrServiceClient(cc grpc.ClientConnInterface) EthPhyIntfCountersMgrServiceClient {
	return &ethPhyIntfCountersMgrServiceClient{cc}
}

func (c *ethPhyIntfCountersMgrServiceClient) Counters(ctx context.Context, in *EthPhyIntfCountersRequest, opts ...grpc.CallOption) (*EthPhyIntfCountersResponse, error) {
	out := new(EthPhyIntfCountersResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.EthPhyIntfCountersMgrService/counters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ethPhyIntfCountersMgrServiceClient) BinCounters(ctx context.Context, in *EthPhyIntfBinCountersRequest, opts ...grpc.CallOption) (*EthPhyIntfBinCountersResponse, error) {
	out := new(EthPhyIntfBinCountersResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.EthPhyIntfCountersMgrService/bin_counters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EthPhyIntfCountersMgrServiceServer is the server API for EthPhyIntfCountersMgrService service.
// All implementations should embed UnimplementedEthPhyIntfCountersMgrServiceServer
// for forward compatibility
type EthPhyIntfCountersMgrServiceServer interface {
	// *
	// Gets the current counters of the given ethernet interface.
	//
	// EOS SDK reference: eos::eth_phy_intf_counter_mgr::counters
	Counters(context.Context, *EthPhyIntfCountersRequest) (*EthPhyIntfCountersResponse, error)
	// *
	// Gets the current bin counters of the given ethernet interface.
	//
	// EOS SDK reference: eos::eth_phy_intf_counter_mgr::bin_counters
	BinCounters(context.Context, *EthPhyIntfBinCountersRequest) (*EthPhyIntfBinCountersResponse, error)
}

// UnimplementedEthPhyIntfCountersMgrServiceServer should be embedded to have forward compatible implementations.
type UnimplementedEthPhyIntfCountersMgrServiceServer struct {
}

func (UnimplementedEthPhyIntfCountersMgrServiceServer) Counters(context.Context, *EthPhyIntfCountersRequest) (*EthPhyIntfCountersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Counters not implemented")
}
func (UnimplementedEthPhyIntfCountersMgrServiceServer) BinCounters(context.Context, *EthPhyIntfBinCountersRequest) (*EthPhyIntfBinCountersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BinCounters not implemented")
}

// UnsafeEthPhyIntfCountersMgrServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EthPhyIntfCountersMgrServiceServer will
// result in compilation errors.
type UnsafeEthPhyIntfCountersMgrServiceServer interface {
	mustEmbedUnimplementedEthPhyIntfCountersMgrServiceServer()
}

func RegisterEthPhyIntfCountersMgrServiceServer(s grpc.ServiceRegistrar, srv EthPhyIntfCountersMgrServiceServer) {
	s.RegisterService(&EthPhyIntfCountersMgrService_ServiceDesc, srv)
}

func _EthPhyIntfCountersMgrService_Counters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EthPhyIntfCountersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthPhyIntfCountersMgrServiceServer).Counters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.EthPhyIntfCountersMgrService/counters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthPhyIntfCountersMgrServiceServer).Counters(ctx, req.(*EthPhyIntfCountersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EthPhyIntfCountersMgrService_BinCounters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EthPhyIntfBinCountersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EthPhyIntfCountersMgrServiceServer).BinCounters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.EthPhyIntfCountersMgrService/bin_counters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EthPhyIntfCountersMgrServiceServer).BinCounters(ctx, req.(*EthPhyIntfBinCountersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EthPhyIntfCountersMgrService_ServiceDesc is the grpc.ServiceDesc for EthPhyIntfCountersMgrService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EthPhyIntfCountersMgrService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eos.remote.EthPhyIntfCountersMgrService",
	HandlerType: (*EthPhyIntfCountersMgrServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "counters",
			Handler:    _EthPhyIntfCountersMgrService_Counters_Handler,
		},
		{
			MethodName: "bin_counters",
			Handler:    _EthPhyIntfCountersMgrService_BinCounters_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eth_phy_intf.proto",
}
