"""Fixture-based compatibility tests.

These tests deserialize binary fixtures generated by the Rust fixture
generator and verify that Python's deserialized field values match the
expected values from the JSON sidecar files.

Regenerate fixtures:
    cd ../../../testdata/fixtures/generate-fixtures && cargo run
"""

import json
from pathlib import Path

import pytest
from solders.pubkey import Pubkey  # type: ignore[import-untyped]

from revdist.discriminator import (
    DISCRIMINATOR_CONTRIBUTOR_REWARDS,
    DISCRIMINATOR_DISTRIBUTION,
    DISCRIMINATOR_JOURNAL,
    DISCRIMINATOR_PROGRAM_CONFIG,
    DISCRIMINATOR_SOLANA_VALIDATOR_DEPOSIT,
)
from revdist.state import (
    ContributorRewards,
    Distribution,
    Journal,
    ProgramConfig,
    SolanaValidatorDeposit,
)

FIXTURES_DIR = Path(__file__).resolve().parent.parent.parent.parent / "testdata" / "fixtures"

# Field name mapping: JSON (Go-style PascalCase) -> Python attribute path
# Each entry is (json_name, accessor_callable)
# Built per-type below.


def _load_fixture(name: str) -> tuple[bytes, dict]:
    bin_data = (FIXTURES_DIR / f"{name}.bin").read_bytes()
    meta = json.loads((FIXTURES_DIR / f"{name}.json").read_text())
    return bin_data, meta


def _assert_field(obj, field: dict, field_map: dict) -> None:
    name = field["name"]
    typ = field["typ"]
    raw_value = field["value"]

    if name not in field_map:
        pytest.skip(f"field {name} not mapped")

    got = field_map[name]

    if typ in ("u8", "u16", "u32", "u64"):
        assert got == int(raw_value), f"{name}: expected {raw_value}, got {got}"
    elif typ == "pubkey":
        expected = Pubkey.from_string(raw_value)
        assert got == expected, f"{name}: expected {expected}, got {got}"
    else:
        raise ValueError(f"unknown type {typ}")


class TestFixtureProgramConfig:
    def test_deserialize(self):
        data, meta = _load_fixture("program_config")
        assert ProgramConfig.STRUCT_SIZE == meta["struct_size"]

        config = ProgramConfig.from_bytes(data, DISCRIMINATOR_PROGRAM_CONFIG)

        field_map = {
            "Flags": config.flags,
            "NextCompletedDZEpoch": config.next_completed_dz_epoch,
            "BumpSeed": config.bump_seed,
            "AdminKey": config.admin_key,
            "DebtAccountantKey": config.debt_accountant_key,
            "RewardsAccountantKey": config.rewards_accountant_key,
            "ContributorManagerKey": config.contributor_manager_key,
            "SOL2ZSwapProgramID": config.sol_2z_swap_program_id,
            "CalculationGracePeriodMinutes": config.distribution_parameters.calculation_grace_period_minutes,
            "InitializationGracePeriodMinutes": config.distribution_parameters.initialization_grace_period_minutes,
            "MinimumEpochDurationToFinalizeRewards": config.distribution_parameters.minimum_epoch_duration_to_finalize_rewards,
            "BurnRateLimit": config.distribution_parameters.community_burn_rate_parameters.limit,
            "BurnRateDZEpochsToIncreasing": config.distribution_parameters.community_burn_rate_parameters.dz_epochs_to_increasing,
            "BurnRateDZEpochsToLimit": config.distribution_parameters.community_burn_rate_parameters.dz_epochs_to_limit,
            "BaseBlockRewardsPct": config.distribution_parameters.solana_validator_fee_parameters.base_block_rewards_pct,
            "PriorityBlockRewardsPct": config.distribution_parameters.solana_validator_fee_parameters.priority_block_rewards_pct,
            "InflationRewardsPct": config.distribution_parameters.solana_validator_fee_parameters.inflation_rewards_pct,
            "JitoTipsPct": config.distribution_parameters.solana_validator_fee_parameters.jito_tips_pct,
            "FixedSOLAmount": config.distribution_parameters.solana_validator_fee_parameters.fixed_sol_amount,
            "DistributeRewardsLamports": config.relay_parameters.distribute_rewards_lamports,
            "DebtWriteOffFeatureActivationEpoch": config.debt_write_off_feature_activation_epoch,
        }

        for field in meta["fields"]:
            _assert_field(config, field, field_map)

    def test_tolerates_extra_bytes(self):
        data, _ = _load_fixture("program_config")
        extended = data + b"\x00" * 64
        config = ProgramConfig.from_bytes(extended, DISCRIMINATOR_PROGRAM_CONFIG)
        assert config.flags == 1


class TestFixtureDistribution:
    def test_deserialize(self):
        data, meta = _load_fixture("distribution")
        assert Distribution.STRUCT_SIZE == meta["struct_size"]

        dist = Distribution.from_bytes(data, DISCRIMINATOR_DISTRIBUTION)

        field_map = {
            "DZEpoch": dist.dz_epoch,
            "Flags": dist.flags,
            "CommunityBurnRate": dist.community_burn_rate,
            "BaseBlockRewardsPct": dist.solana_validator_fee_parameters.base_block_rewards_pct,
            "PriorityBlockRewardsPct": dist.solana_validator_fee_parameters.priority_block_rewards_pct,
            "InflationRewardsPct": dist.solana_validator_fee_parameters.inflation_rewards_pct,
            "JitoTipsPct": dist.solana_validator_fee_parameters.jito_tips_pct,
            "FixedSOLAmount": dist.solana_validator_fee_parameters.fixed_sol_amount,
            "TotalSolanaValidators": dist.total_solana_validators,
            "SolanaValidatorPaymentsCount": dist.solana_validator_payments_count,
            "TotalSolanaValidatorDebt": dist.total_solana_validator_debt,
            "CollectedSolanaValidatorPayments": dist.collected_solana_validator_payments,
            "TotalContributors": dist.total_contributors,
            "DistributedRewardsCount": dist.distributed_rewards_count,
            "CollectedPrepaid2ZPayments": dist.collected_prepaid_2z_payments,
            "Collected2ZConvertedFromSOL": dist.collected_2z_converted_from_sol,
            "UncollectibleSOLDebt": dist.uncollectible_sol_debt,
            "Distributed2ZAmount": dist.distributed_2z_amount,
            "Burned2ZAmount": dist.burned_2z_amount,
            "SolanaValidatorWriteOffCount": dist.solana_validator_write_off_count,
        }

        for field in meta["fields"]:
            _assert_field(dist, field, field_map)


class TestFixtureJournal:
    def test_deserialize(self):
        data, meta = _load_fixture("journal")
        assert Journal.STRUCT_SIZE == meta["struct_size"]

        journal = Journal.from_bytes(data, DISCRIMINATOR_JOURNAL)

        field_map = {
            "BumpSeed": journal.bump_seed,
            "TotalSOLBalance": journal.total_sol_balance,
            "Total2ZBalance": journal.total_2z_balance,
            "Swap2ZDestinationBalance": journal.swap_2z_destination_balance,
            "SwappedSOLAmount": journal.swapped_sol_amount,
            "NextDZEpochToSweepTokens": journal.next_dz_epoch_to_sweep_tokens,
        }

        for field in meta["fields"]:
            _assert_field(journal, field, field_map)


class TestFixtureSolanaValidatorDeposit:
    def test_deserialize(self):
        data, meta = _load_fixture("solana_validator_deposit")
        assert SolanaValidatorDeposit.STRUCT_SIZE == meta["struct_size"]

        deposit = SolanaValidatorDeposit.from_bytes(
            data, DISCRIMINATOR_SOLANA_VALIDATOR_DEPOSIT
        )

        field_map = {
            "NodeID": deposit.node_id,
            "WrittenOffSOLDebt": deposit.written_off_sol_debt,
        }

        for field in meta["fields"]:
            _assert_field(deposit, field, field_map)


class TestFixtureContributorRewards:
    def test_deserialize(self):
        data, meta = _load_fixture("contributor_rewards")
        assert ContributorRewards.STRUCT_SIZE == meta["struct_size"]

        rewards = ContributorRewards.from_bytes(
            data, DISCRIMINATOR_CONTRIBUTOR_REWARDS
        )

        field_map = {
            "RewardsManagerKey": rewards.rewards_manager_key,
            "ServiceKey": rewards.service_key,
            "Flags": rewards.flags,
        }

        for field in meta["fields"]:
            _assert_field(rewards, field, field_map)
