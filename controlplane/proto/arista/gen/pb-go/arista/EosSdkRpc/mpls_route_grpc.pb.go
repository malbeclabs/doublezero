// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.6
// source: mpls_route.proto

package EosSdkRpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MplsRouteMgrServiceClient is the client API for MplsRouteMgrService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MplsRouteMgrServiceClient interface {
	// *
	// Subscription to monitor changes to MPLS routes in hardware. This request stays
	// active until the client cancels or the server shuts down.
	//
	// EosSdk reference: eos::mpls_route_handler (class)
	Watch(ctx context.Context, in *MplsRouteWatchRequest, opts ...grpc.CallOption) (MplsRouteMgrService_WatchClient, error)
	// *
	// Initiate a MPLS resync proccess. Starts a blank configuration to be applied once
	// resync_complete is called.
	//
	// EosSdk reference: eos::mpls_route_mgr::resync_init
	ResyncInit(ctx context.Context, in *MplsRouteResyncInitRequest, opts ...grpc.CallOption) (*MplsRouteResyncInitResponse, error)
	// *
	// Ends the current MPLS resync process. Deletes the current configuration and
	// applies all changes since resync_init was called.
	//
	// EosSdk reference: eos::mpls_route_mgr::resync_complete
	ResyncComplete(ctx context.Context, in *MplsRouteResyncCompleteRequest, opts ...grpc.CallOption) (*MplsRouteResyncCompleteResponse, error)
	// *
	// Returns a list of all configured MPLS routes.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_iter
	MplsRoutes(ctx context.Context, in *MplsRoutesRequest, opts ...grpc.CallOption) (MplsRouteMgrService_MplsRoutesClient, error)
	// *
	// Returns a list of all MPLS routes in hardware.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_status_iter_t
	MplsRouteStatuses(ctx context.Context, in *MplsRouteStatusesRequest, opts ...grpc.CallOption) (MplsRouteMgrService_MplsRouteStatusesClient, error)
	// *
	// Returns a list of configured MPLS vias for a specified route.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_via_iter_t
	MplsRouteVias(ctx context.Context, in *MplsRouteViasRequest, opts ...grpc.CallOption) (MplsRouteMgrService_MplsRouteViasClient, error)
	// *
	// Returns a list of MPLS vias in hardware for a specified MPLS route or FEC.
	//
	// The vias returned for a MPLS FEC are unbound meaning they do not have a
	// route key.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_via_status_iter_t
	MplsRouteViaStatuses(ctx context.Context, in *MplsRouteViaStatusesRequest, opts ...grpc.CallOption) (MplsRouteMgrService_MplsRouteViaStatusesClient, error)
	// *
	// Queries whether the specified route or via exists in the switch config.
	//
	// EosSdk reference: eos::mpls_route_mgr::exists
	Exists(ctx context.Context, in *MplsRouteExistsRequest, opts ...grpc.CallOption) (*MplsRouteExistsResponse, error)
	// *
	// Inserts or updates an MPLS static route in the switch config.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_set
	MplsRouteSet(ctx context.Context, in *MplsRouteSetRequest, opts ...grpc.CallOption) (*MplsRouteSetResponse, error)
	// *
	// Inserts or updates multiple MPLS static routes in the switch config in a single
	// call.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_set
	BulkMplsRouteSet(ctx context.Context, in *BulkMplsRouteSetRequest, opts ...grpc.CallOption) (*BulkMplsRouteSetResponse, error)
	// *
	// Removes the MPLS route and all vias matching its route key.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_del
	MplsRouteDel(ctx context.Context, in *MplsRouteDelRequest, opts ...grpc.CallOption) (*MplsRouteDelResponse, error)
	// *
	// Removes multiple MPLS routes and all vias matching their route keys in a single
	// call.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_del
	BulkMplsRouteDel(ctx context.Context, in *BulkMplsRouteDelRequest, opts ...grpc.CallOption) (*BulkMplsRouteDelResponse, error)
	// *
	// Add the specified via to its associated MPLS route.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_via_set
	MplsRouteViaSet(ctx context.Context, in *MplsRouteViaSetRequest, opts ...grpc.CallOption) (*MplsRouteViaSetResponse, error)
	// *
	// Adds multiple vias to their associated MPLS routes in a single call.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_via_set
	BulkMplsRouteViaSet(ctx context.Context, in *BulkMplsRouteViaSetRequest, opts ...grpc.CallOption) (*BulkMplsRouteViaSetResponse, error)
	// *
	// Removes the specified via from its associated MPLS route. If all vias are
	// removed from a route it will still exist but it will have no nexthop
	// information.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_via_del
	MplsRouteViaDel(ctx context.Context, in *MplsRouteViaDelRequest, opts ...grpc.CallOption) (*MplsRouteViaDelResponse, error)
	// *
	// Removes multiple vias from their associated MPLS routes in a single call.
	// If all vias are removed from a route it will still exist but it will have
	// no nexthop information.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_via_del
	BulkMplsRouteViaDel(ctx context.Context, in *BulkMplsRouteViaDelRequest, opts ...grpc.CallOption) (*BulkMplsRouteViaDelResponse, error)
	// *
	// Returns the FEC ID corresponding to the specified MPLS route key if the route is
	// programmed in hardware. If it is not programmed in hardware then the FEC ID will
	// be 0 denoting that it is not set.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_fec_id
	FecId(ctx context.Context, in *MplsRouteFecIdRequest, opts ...grpc.CallOption) (*MplsRouteFecIdResponse, error)
	// *
	// Returns the active metric that is being used in hardware to forward traffic for
	// the specified MPLS route key, or 0 if the route key does not have any active
	// vias programmed.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_metric
	Metric(ctx context.Context, in *MplsRouteMetricRequest, opts ...grpc.CallOption) (*MplsRouteMetricResponse, error)
}

type mplsRouteMgrServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMplsRouteMgrServiceClient(cc grpc.ClientConnInterface) MplsRouteMgrServiceClient {
	return &mplsRouteMgrServiceClient{cc}
}

func (c *mplsRouteMgrServiceClient) Watch(ctx context.Context, in *MplsRouteWatchRequest, opts ...grpc.CallOption) (MplsRouteMgrService_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &MplsRouteMgrService_ServiceDesc.Streams[0], "/eos.remote.MplsRouteMgrService/watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &mplsRouteMgrServiceWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MplsRouteMgrService_WatchClient interface {
	Recv() (*MplsRouteWatchResponse, error)
	grpc.ClientStream
}

type mplsRouteMgrServiceWatchClient struct {
	grpc.ClientStream
}

func (x *mplsRouteMgrServiceWatchClient) Recv() (*MplsRouteWatchResponse, error) {
	m := new(MplsRouteWatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mplsRouteMgrServiceClient) ResyncInit(ctx context.Context, in *MplsRouteResyncInitRequest, opts ...grpc.CallOption) (*MplsRouteResyncInitResponse, error) {
	out := new(MplsRouteResyncInitResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.MplsRouteMgrService/resync_init", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mplsRouteMgrServiceClient) ResyncComplete(ctx context.Context, in *MplsRouteResyncCompleteRequest, opts ...grpc.CallOption) (*MplsRouteResyncCompleteResponse, error) {
	out := new(MplsRouteResyncCompleteResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.MplsRouteMgrService/resync_complete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mplsRouteMgrServiceClient) MplsRoutes(ctx context.Context, in *MplsRoutesRequest, opts ...grpc.CallOption) (MplsRouteMgrService_MplsRoutesClient, error) {
	stream, err := c.cc.NewStream(ctx, &MplsRouteMgrService_ServiceDesc.Streams[1], "/eos.remote.MplsRouteMgrService/mpls_routes", opts...)
	if err != nil {
		return nil, err
	}
	x := &mplsRouteMgrServiceMplsRoutesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MplsRouteMgrService_MplsRoutesClient interface {
	Recv() (*MplsRoutesResponse, error)
	grpc.ClientStream
}

type mplsRouteMgrServiceMplsRoutesClient struct {
	grpc.ClientStream
}

func (x *mplsRouteMgrServiceMplsRoutesClient) Recv() (*MplsRoutesResponse, error) {
	m := new(MplsRoutesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mplsRouteMgrServiceClient) MplsRouteStatuses(ctx context.Context, in *MplsRouteStatusesRequest, opts ...grpc.CallOption) (MplsRouteMgrService_MplsRouteStatusesClient, error) {
	stream, err := c.cc.NewStream(ctx, &MplsRouteMgrService_ServiceDesc.Streams[2], "/eos.remote.MplsRouteMgrService/mpls_route_statuses", opts...)
	if err != nil {
		return nil, err
	}
	x := &mplsRouteMgrServiceMplsRouteStatusesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MplsRouteMgrService_MplsRouteStatusesClient interface {
	Recv() (*MplsRouteStatusesResponse, error)
	grpc.ClientStream
}

type mplsRouteMgrServiceMplsRouteStatusesClient struct {
	grpc.ClientStream
}

func (x *mplsRouteMgrServiceMplsRouteStatusesClient) Recv() (*MplsRouteStatusesResponse, error) {
	m := new(MplsRouteStatusesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mplsRouteMgrServiceClient) MplsRouteVias(ctx context.Context, in *MplsRouteViasRequest, opts ...grpc.CallOption) (MplsRouteMgrService_MplsRouteViasClient, error) {
	stream, err := c.cc.NewStream(ctx, &MplsRouteMgrService_ServiceDesc.Streams[3], "/eos.remote.MplsRouteMgrService/mpls_route_vias", opts...)
	if err != nil {
		return nil, err
	}
	x := &mplsRouteMgrServiceMplsRouteViasClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MplsRouteMgrService_MplsRouteViasClient interface {
	Recv() (*MplsRouteViasResponse, error)
	grpc.ClientStream
}

type mplsRouteMgrServiceMplsRouteViasClient struct {
	grpc.ClientStream
}

func (x *mplsRouteMgrServiceMplsRouteViasClient) Recv() (*MplsRouteViasResponse, error) {
	m := new(MplsRouteViasResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mplsRouteMgrServiceClient) MplsRouteViaStatuses(ctx context.Context, in *MplsRouteViaStatusesRequest, opts ...grpc.CallOption) (MplsRouteMgrService_MplsRouteViaStatusesClient, error) {
	stream, err := c.cc.NewStream(ctx, &MplsRouteMgrService_ServiceDesc.Streams[4], "/eos.remote.MplsRouteMgrService/mpls_route_via_statuses", opts...)
	if err != nil {
		return nil, err
	}
	x := &mplsRouteMgrServiceMplsRouteViaStatusesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MplsRouteMgrService_MplsRouteViaStatusesClient interface {
	Recv() (*MplsRouteViaStatusesResponse, error)
	grpc.ClientStream
}

type mplsRouteMgrServiceMplsRouteViaStatusesClient struct {
	grpc.ClientStream
}

func (x *mplsRouteMgrServiceMplsRouteViaStatusesClient) Recv() (*MplsRouteViaStatusesResponse, error) {
	m := new(MplsRouteViaStatusesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *mplsRouteMgrServiceClient) Exists(ctx context.Context, in *MplsRouteExistsRequest, opts ...grpc.CallOption) (*MplsRouteExistsResponse, error) {
	out := new(MplsRouteExistsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.MplsRouteMgrService/exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mplsRouteMgrServiceClient) MplsRouteSet(ctx context.Context, in *MplsRouteSetRequest, opts ...grpc.CallOption) (*MplsRouteSetResponse, error) {
	out := new(MplsRouteSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.MplsRouteMgrService/mpls_route_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mplsRouteMgrServiceClient) BulkMplsRouteSet(ctx context.Context, in *BulkMplsRouteSetRequest, opts ...grpc.CallOption) (*BulkMplsRouteSetResponse, error) {
	out := new(BulkMplsRouteSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.MplsRouteMgrService/bulk_mpls_route_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mplsRouteMgrServiceClient) MplsRouteDel(ctx context.Context, in *MplsRouteDelRequest, opts ...grpc.CallOption) (*MplsRouteDelResponse, error) {
	out := new(MplsRouteDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.MplsRouteMgrService/mpls_route_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mplsRouteMgrServiceClient) BulkMplsRouteDel(ctx context.Context, in *BulkMplsRouteDelRequest, opts ...grpc.CallOption) (*BulkMplsRouteDelResponse, error) {
	out := new(BulkMplsRouteDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.MplsRouteMgrService/bulk_mpls_route_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mplsRouteMgrServiceClient) MplsRouteViaSet(ctx context.Context, in *MplsRouteViaSetRequest, opts ...grpc.CallOption) (*MplsRouteViaSetResponse, error) {
	out := new(MplsRouteViaSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.MplsRouteMgrService/mpls_route_via_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mplsRouteMgrServiceClient) BulkMplsRouteViaSet(ctx context.Context, in *BulkMplsRouteViaSetRequest, opts ...grpc.CallOption) (*BulkMplsRouteViaSetResponse, error) {
	out := new(BulkMplsRouteViaSetResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.MplsRouteMgrService/bulk_mpls_route_via_set", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mplsRouteMgrServiceClient) MplsRouteViaDel(ctx context.Context, in *MplsRouteViaDelRequest, opts ...grpc.CallOption) (*MplsRouteViaDelResponse, error) {
	out := new(MplsRouteViaDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.MplsRouteMgrService/mpls_route_via_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mplsRouteMgrServiceClient) BulkMplsRouteViaDel(ctx context.Context, in *BulkMplsRouteViaDelRequest, opts ...grpc.CallOption) (*BulkMplsRouteViaDelResponse, error) {
	out := new(BulkMplsRouteViaDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.MplsRouteMgrService/bulk_mpls_route_via_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mplsRouteMgrServiceClient) FecId(ctx context.Context, in *MplsRouteFecIdRequest, opts ...grpc.CallOption) (*MplsRouteFecIdResponse, error) {
	out := new(MplsRouteFecIdResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.MplsRouteMgrService/fec_id", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mplsRouteMgrServiceClient) Metric(ctx context.Context, in *MplsRouteMetricRequest, opts ...grpc.CallOption) (*MplsRouteMetricResponse, error) {
	out := new(MplsRouteMetricResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.MplsRouteMgrService/metric", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MplsRouteMgrServiceServer is the server API for MplsRouteMgrService service.
// All implementations should embed UnimplementedMplsRouteMgrServiceServer
// for forward compatibility
type MplsRouteMgrServiceServer interface {
	// *
	// Subscription to monitor changes to MPLS routes in hardware. This request stays
	// active until the client cancels or the server shuts down.
	//
	// EosSdk reference: eos::mpls_route_handler (class)
	Watch(*MplsRouteWatchRequest, MplsRouteMgrService_WatchServer) error
	// *
	// Initiate a MPLS resync proccess. Starts a blank configuration to be applied once
	// resync_complete is called.
	//
	// EosSdk reference: eos::mpls_route_mgr::resync_init
	ResyncInit(context.Context, *MplsRouteResyncInitRequest) (*MplsRouteResyncInitResponse, error)
	// *
	// Ends the current MPLS resync process. Deletes the current configuration and
	// applies all changes since resync_init was called.
	//
	// EosSdk reference: eos::mpls_route_mgr::resync_complete
	ResyncComplete(context.Context, *MplsRouteResyncCompleteRequest) (*MplsRouteResyncCompleteResponse, error)
	// *
	// Returns a list of all configured MPLS routes.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_iter
	MplsRoutes(*MplsRoutesRequest, MplsRouteMgrService_MplsRoutesServer) error
	// *
	// Returns a list of all MPLS routes in hardware.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_status_iter_t
	MplsRouteStatuses(*MplsRouteStatusesRequest, MplsRouteMgrService_MplsRouteStatusesServer) error
	// *
	// Returns a list of configured MPLS vias for a specified route.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_via_iter_t
	MplsRouteVias(*MplsRouteViasRequest, MplsRouteMgrService_MplsRouteViasServer) error
	// *
	// Returns a list of MPLS vias in hardware for a specified MPLS route or FEC.
	//
	// The vias returned for a MPLS FEC are unbound meaning they do not have a
	// route key.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_via_status_iter_t
	MplsRouteViaStatuses(*MplsRouteViaStatusesRequest, MplsRouteMgrService_MplsRouteViaStatusesServer) error
	// *
	// Queries whether the specified route or via exists in the switch config.
	//
	// EosSdk reference: eos::mpls_route_mgr::exists
	Exists(context.Context, *MplsRouteExistsRequest) (*MplsRouteExistsResponse, error)
	// *
	// Inserts or updates an MPLS static route in the switch config.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_set
	MplsRouteSet(context.Context, *MplsRouteSetRequest) (*MplsRouteSetResponse, error)
	// *
	// Inserts or updates multiple MPLS static routes in the switch config in a single
	// call.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_set
	BulkMplsRouteSet(context.Context, *BulkMplsRouteSetRequest) (*BulkMplsRouteSetResponse, error)
	// *
	// Removes the MPLS route and all vias matching its route key.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_del
	MplsRouteDel(context.Context, *MplsRouteDelRequest) (*MplsRouteDelResponse, error)
	// *
	// Removes multiple MPLS routes and all vias matching their route keys in a single
	// call.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_del
	BulkMplsRouteDel(context.Context, *BulkMplsRouteDelRequest) (*BulkMplsRouteDelResponse, error)
	// *
	// Add the specified via to its associated MPLS route.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_via_set
	MplsRouteViaSet(context.Context, *MplsRouteViaSetRequest) (*MplsRouteViaSetResponse, error)
	// *
	// Adds multiple vias to their associated MPLS routes in a single call.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_via_set
	BulkMplsRouteViaSet(context.Context, *BulkMplsRouteViaSetRequest) (*BulkMplsRouteViaSetResponse, error)
	// *
	// Removes the specified via from its associated MPLS route. If all vias are
	// removed from a route it will still exist but it will have no nexthop
	// information.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_via_del
	MplsRouteViaDel(context.Context, *MplsRouteViaDelRequest) (*MplsRouteViaDelResponse, error)
	// *
	// Removes multiple vias from their associated MPLS routes in a single call.
	// If all vias are removed from a route it will still exist but it will have
	// no nexthop information.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_via_del
	BulkMplsRouteViaDel(context.Context, *BulkMplsRouteViaDelRequest) (*BulkMplsRouteViaDelResponse, error)
	// *
	// Returns the FEC ID corresponding to the specified MPLS route key if the route is
	// programmed in hardware. If it is not programmed in hardware then the FEC ID will
	// be 0 denoting that it is not set.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_fec_id
	FecId(context.Context, *MplsRouteFecIdRequest) (*MplsRouteFecIdResponse, error)
	// *
	// Returns the active metric that is being used in hardware to forward traffic for
	// the specified MPLS route key, or 0 if the route key does not have any active
	// vias programmed.
	//
	// EosSdk reference: eos::mpls_route_mgr::mpls_route_metric
	Metric(context.Context, *MplsRouteMetricRequest) (*MplsRouteMetricResponse, error)
}

// UnimplementedMplsRouteMgrServiceServer should be embedded to have forward compatible implementations.
type UnimplementedMplsRouteMgrServiceServer struct {
}

func (UnimplementedMplsRouteMgrServiceServer) Watch(*MplsRouteWatchRequest, MplsRouteMgrService_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) ResyncInit(context.Context, *MplsRouteResyncInitRequest) (*MplsRouteResyncInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResyncInit not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) ResyncComplete(context.Context, *MplsRouteResyncCompleteRequest) (*MplsRouteResyncCompleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResyncComplete not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) MplsRoutes(*MplsRoutesRequest, MplsRouteMgrService_MplsRoutesServer) error {
	return status.Errorf(codes.Unimplemented, "method MplsRoutes not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) MplsRouteStatuses(*MplsRouteStatusesRequest, MplsRouteMgrService_MplsRouteStatusesServer) error {
	return status.Errorf(codes.Unimplemented, "method MplsRouteStatuses not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) MplsRouteVias(*MplsRouteViasRequest, MplsRouteMgrService_MplsRouteViasServer) error {
	return status.Errorf(codes.Unimplemented, "method MplsRouteVias not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) MplsRouteViaStatuses(*MplsRouteViaStatusesRequest, MplsRouteMgrService_MplsRouteViaStatusesServer) error {
	return status.Errorf(codes.Unimplemented, "method MplsRouteViaStatuses not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) Exists(context.Context, *MplsRouteExistsRequest) (*MplsRouteExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exists not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) MplsRouteSet(context.Context, *MplsRouteSetRequest) (*MplsRouteSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MplsRouteSet not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) BulkMplsRouteSet(context.Context, *BulkMplsRouteSetRequest) (*BulkMplsRouteSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkMplsRouteSet not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) MplsRouteDel(context.Context, *MplsRouteDelRequest) (*MplsRouteDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MplsRouteDel not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) BulkMplsRouteDel(context.Context, *BulkMplsRouteDelRequest) (*BulkMplsRouteDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkMplsRouteDel not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) MplsRouteViaSet(context.Context, *MplsRouteViaSetRequest) (*MplsRouteViaSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MplsRouteViaSet not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) BulkMplsRouteViaSet(context.Context, *BulkMplsRouteViaSetRequest) (*BulkMplsRouteViaSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkMplsRouteViaSet not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) MplsRouteViaDel(context.Context, *MplsRouteViaDelRequest) (*MplsRouteViaDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MplsRouteViaDel not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) BulkMplsRouteViaDel(context.Context, *BulkMplsRouteViaDelRequest) (*BulkMplsRouteViaDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkMplsRouteViaDel not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) FecId(context.Context, *MplsRouteFecIdRequest) (*MplsRouteFecIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FecId not implemented")
}
func (UnimplementedMplsRouteMgrServiceServer) Metric(context.Context, *MplsRouteMetricRequest) (*MplsRouteMetricResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Metric not implemented")
}

// UnsafeMplsRouteMgrServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MplsRouteMgrServiceServer will
// result in compilation errors.
type UnsafeMplsRouteMgrServiceServer interface {
	mustEmbedUnimplementedMplsRouteMgrServiceServer()
}

func RegisterMplsRouteMgrServiceServer(s grpc.ServiceRegistrar, srv MplsRouteMgrServiceServer) {
	s.RegisterService(&MplsRouteMgrService_ServiceDesc, srv)
}

func _MplsRouteMgrService_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MplsRouteWatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MplsRouteMgrServiceServer).Watch(m, &mplsRouteMgrServiceWatchServer{stream})
}

type MplsRouteMgrService_WatchServer interface {
	Send(*MplsRouteWatchResponse) error
	grpc.ServerStream
}

type mplsRouteMgrServiceWatchServer struct {
	grpc.ServerStream
}

func (x *mplsRouteMgrServiceWatchServer) Send(m *MplsRouteWatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MplsRouteMgrService_ResyncInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MplsRouteResyncInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MplsRouteMgrServiceServer).ResyncInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.MplsRouteMgrService/resync_init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MplsRouteMgrServiceServer).ResyncInit(ctx, req.(*MplsRouteResyncInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MplsRouteMgrService_ResyncComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MplsRouteResyncCompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MplsRouteMgrServiceServer).ResyncComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.MplsRouteMgrService/resync_complete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MplsRouteMgrServiceServer).ResyncComplete(ctx, req.(*MplsRouteResyncCompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MplsRouteMgrService_MplsRoutes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MplsRoutesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MplsRouteMgrServiceServer).MplsRoutes(m, &mplsRouteMgrServiceMplsRoutesServer{stream})
}

type MplsRouteMgrService_MplsRoutesServer interface {
	Send(*MplsRoutesResponse) error
	grpc.ServerStream
}

type mplsRouteMgrServiceMplsRoutesServer struct {
	grpc.ServerStream
}

func (x *mplsRouteMgrServiceMplsRoutesServer) Send(m *MplsRoutesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MplsRouteMgrService_MplsRouteStatuses_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MplsRouteStatusesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MplsRouteMgrServiceServer).MplsRouteStatuses(m, &mplsRouteMgrServiceMplsRouteStatusesServer{stream})
}

type MplsRouteMgrService_MplsRouteStatusesServer interface {
	Send(*MplsRouteStatusesResponse) error
	grpc.ServerStream
}

type mplsRouteMgrServiceMplsRouteStatusesServer struct {
	grpc.ServerStream
}

func (x *mplsRouteMgrServiceMplsRouteStatusesServer) Send(m *MplsRouteStatusesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MplsRouteMgrService_MplsRouteVias_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MplsRouteViasRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MplsRouteMgrServiceServer).MplsRouteVias(m, &mplsRouteMgrServiceMplsRouteViasServer{stream})
}

type MplsRouteMgrService_MplsRouteViasServer interface {
	Send(*MplsRouteViasResponse) error
	grpc.ServerStream
}

type mplsRouteMgrServiceMplsRouteViasServer struct {
	grpc.ServerStream
}

func (x *mplsRouteMgrServiceMplsRouteViasServer) Send(m *MplsRouteViasResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MplsRouteMgrService_MplsRouteViaStatuses_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MplsRouteViaStatusesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MplsRouteMgrServiceServer).MplsRouteViaStatuses(m, &mplsRouteMgrServiceMplsRouteViaStatusesServer{stream})
}

type MplsRouteMgrService_MplsRouteViaStatusesServer interface {
	Send(*MplsRouteViaStatusesResponse) error
	grpc.ServerStream
}

type mplsRouteMgrServiceMplsRouteViaStatusesServer struct {
	grpc.ServerStream
}

func (x *mplsRouteMgrServiceMplsRouteViaStatusesServer) Send(m *MplsRouteViaStatusesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MplsRouteMgrService_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MplsRouteExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MplsRouteMgrServiceServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.MplsRouteMgrService/exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MplsRouteMgrServiceServer).Exists(ctx, req.(*MplsRouteExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MplsRouteMgrService_MplsRouteSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MplsRouteSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MplsRouteMgrServiceServer).MplsRouteSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.MplsRouteMgrService/mpls_route_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MplsRouteMgrServiceServer).MplsRouteSet(ctx, req.(*MplsRouteSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MplsRouteMgrService_BulkMplsRouteSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkMplsRouteSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MplsRouteMgrServiceServer).BulkMplsRouteSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.MplsRouteMgrService/bulk_mpls_route_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MplsRouteMgrServiceServer).BulkMplsRouteSet(ctx, req.(*BulkMplsRouteSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MplsRouteMgrService_MplsRouteDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MplsRouteDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MplsRouteMgrServiceServer).MplsRouteDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.MplsRouteMgrService/mpls_route_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MplsRouteMgrServiceServer).MplsRouteDel(ctx, req.(*MplsRouteDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MplsRouteMgrService_BulkMplsRouteDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkMplsRouteDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MplsRouteMgrServiceServer).BulkMplsRouteDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.MplsRouteMgrService/bulk_mpls_route_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MplsRouteMgrServiceServer).BulkMplsRouteDel(ctx, req.(*BulkMplsRouteDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MplsRouteMgrService_MplsRouteViaSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MplsRouteViaSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MplsRouteMgrServiceServer).MplsRouteViaSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.MplsRouteMgrService/mpls_route_via_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MplsRouteMgrServiceServer).MplsRouteViaSet(ctx, req.(*MplsRouteViaSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MplsRouteMgrService_BulkMplsRouteViaSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkMplsRouteViaSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MplsRouteMgrServiceServer).BulkMplsRouteViaSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.MplsRouteMgrService/bulk_mpls_route_via_set",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MplsRouteMgrServiceServer).BulkMplsRouteViaSet(ctx, req.(*BulkMplsRouteViaSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MplsRouteMgrService_MplsRouteViaDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MplsRouteViaDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MplsRouteMgrServiceServer).MplsRouteViaDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.MplsRouteMgrService/mpls_route_via_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MplsRouteMgrServiceServer).MplsRouteViaDel(ctx, req.(*MplsRouteViaDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MplsRouteMgrService_BulkMplsRouteViaDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkMplsRouteViaDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MplsRouteMgrServiceServer).BulkMplsRouteViaDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.MplsRouteMgrService/bulk_mpls_route_via_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MplsRouteMgrServiceServer).BulkMplsRouteViaDel(ctx, req.(*BulkMplsRouteViaDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MplsRouteMgrService_FecId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MplsRouteFecIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MplsRouteMgrServiceServer).FecId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.MplsRouteMgrService/fec_id",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MplsRouteMgrServiceServer).FecId(ctx, req.(*MplsRouteFecIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MplsRouteMgrService_Metric_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MplsRouteMetricRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MplsRouteMgrServiceServer).Metric(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.MplsRouteMgrService/metric",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MplsRouteMgrServiceServer).Metric(ctx, req.(*MplsRouteMetricRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MplsRouteMgrService_ServiceDesc is the grpc.ServiceDesc for MplsRouteMgrService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MplsRouteMgrService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eos.remote.MplsRouteMgrService",
	HandlerType: (*MplsRouteMgrServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "resync_init",
			Handler:    _MplsRouteMgrService_ResyncInit_Handler,
		},
		{
			MethodName: "resync_complete",
			Handler:    _MplsRouteMgrService_ResyncComplete_Handler,
		},
		{
			MethodName: "exists",
			Handler:    _MplsRouteMgrService_Exists_Handler,
		},
		{
			MethodName: "mpls_route_set",
			Handler:    _MplsRouteMgrService_MplsRouteSet_Handler,
		},
		{
			MethodName: "bulk_mpls_route_set",
			Handler:    _MplsRouteMgrService_BulkMplsRouteSet_Handler,
		},
		{
			MethodName: "mpls_route_del",
			Handler:    _MplsRouteMgrService_MplsRouteDel_Handler,
		},
		{
			MethodName: "bulk_mpls_route_del",
			Handler:    _MplsRouteMgrService_BulkMplsRouteDel_Handler,
		},
		{
			MethodName: "mpls_route_via_set",
			Handler:    _MplsRouteMgrService_MplsRouteViaSet_Handler,
		},
		{
			MethodName: "bulk_mpls_route_via_set",
			Handler:    _MplsRouteMgrService_BulkMplsRouteViaSet_Handler,
		},
		{
			MethodName: "mpls_route_via_del",
			Handler:    _MplsRouteMgrService_MplsRouteViaDel_Handler,
		},
		{
			MethodName: "bulk_mpls_route_via_del",
			Handler:    _MplsRouteMgrService_BulkMplsRouteViaDel_Handler,
		},
		{
			MethodName: "fec_id",
			Handler:    _MplsRouteMgrService_FecId_Handler,
		},
		{
			MethodName: "metric",
			Handler:    _MplsRouteMgrService_Metric_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "watch",
			Handler:       _MplsRouteMgrService_Watch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "mpls_routes",
			Handler:       _MplsRouteMgrService_MplsRoutes_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "mpls_route_statuses",
			Handler:       _MplsRouteMgrService_MplsRouteStatuses_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "mpls_route_vias",
			Handler:       _MplsRouteMgrService_MplsRouteVias_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "mpls_route_via_statuses",
			Handler:       _MplsRouteMgrService_MplsRouteViaStatuses_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mpls_route.proto",
}
