/**
 * Fixture-based compatibility tests.
 *
 * These tests deserialize binary fixtures generated by the Rust fixture
 * generator and verify that TypeScript's deserialized field values match
 * the expected values from the JSON sidecar files.
 *
 * Regenerate fixtures:
 *   cd ../../../testdata/fixtures/revdist/generate-fixtures && cargo run
 */

import { describe, expect, test } from "bun:test";
import { readFileSync } from "fs";
import { join } from "path";
import { PublicKey } from "@solana/web3.js";
import {
  DISCRIMINATOR_PROGRAM_CONFIG,
  DISCRIMINATOR_DISTRIBUTION,
  DISCRIMINATOR_JOURNAL,
  DISCRIMINATOR_SOLANA_VALIDATOR_DEPOSIT,
  DISCRIMINATOR_CONTRIBUTOR_REWARDS,
} from "../discriminator.js";
import {
  deserializeProgramConfig,
  deserializeDistribution,
  deserializeJournal,
  deserializeSolanaValidatorDeposit,
  deserializeContributorRewards,
  PROGRAM_CONFIG_STRUCT_SIZE,
  DISTRIBUTION_STRUCT_SIZE,
  JOURNAL_STRUCT_SIZE,
  SOLANA_VALIDATOR_DEPOSIT_STRUCT_SIZE,
  CONTRIBUTOR_REWARDS_STRUCT_SIZE,
} from "../state.js";

const FIXTURES_DIR = join(
  __dirname,
  "..",
  "..",
  "..",
  "testdata",
  "fixtures",
  "revdist",
);

interface FieldValue {
  name: string;
  value: string;
  typ: string;
}

interface FixtureMeta {
  name: string;
  struct_size: number;
  discriminator_hex: string;
  fields: FieldValue[];
}

function loadFixture(name: string): [Uint8Array, FixtureMeta] {
  const binData = new Uint8Array(
    readFileSync(join(FIXTURES_DIR, `${name}.bin`)),
  );
  const meta: FixtureMeta = JSON.parse(
    readFileSync(join(FIXTURES_DIR, `${name}.json`), "utf-8"),
  );
  return [binData, meta];
}

function assertField(
  field: FieldValue,
  fieldMap: Record<string, unknown>,
): void {
  const got = fieldMap[field.name];
  if (got === undefined) return; // unmapped field

  switch (field.typ) {
    case "u8":
    case "u16":
    case "u32":
      expect(got).toBe(Number(field.value));
      break;
    case "u64":
      expect(got).toBe(BigInt(field.value));
      break;
    case "pubkey":
      expect((got as PublicKey).toBase58()).toBe(field.value);
      break;
    default:
      throw new Error(`unknown type: ${field.typ}`);
  }
}

describe("ProgramConfig fixture", () => {
  test("deserialize", () => {
    const [data, meta] = loadFixture("program_config");
    expect(PROGRAM_CONFIG_STRUCT_SIZE).toBe(meta.struct_size);

    const config = deserializeProgramConfig(data, DISCRIMINATOR_PROGRAM_CONFIG);

    const fieldMap: Record<string, unknown> = {
      Flags: config.flags,
      NextCompletedDZEpoch: config.nextCompletedDzEpoch,
      BumpSeed: config.bumpSeed,
      AdminKey: config.adminKey,
      DebtAccountantKey: config.debtAccountantKey,
      RewardsAccountantKey: config.rewardsAccountantKey,
      ContributorManagerKey: config.contributorManagerKey,
      SOL2ZSwapProgramID: config.sol2zSwapProgramId,
      CalculationGracePeriodMinutes:
        config.distributionParameters.calculationGracePeriodMinutes,
      InitializationGracePeriodMinutes:
        config.distributionParameters.initializationGracePeriodMinutes,
      MinimumEpochDurationToFinalizeRewards:
        config.distributionParameters.minimumEpochDurationToFinalizeRewards,
      BurnRateLimit:
        config.distributionParameters.communityBurnRateParameters.limit,
      BurnRateDZEpochsToIncreasing:
        config.distributionParameters.communityBurnRateParameters
          .dzEpochsToIncreasing,
      BurnRateDZEpochsToLimit:
        config.distributionParameters.communityBurnRateParameters
          .dzEpochsToLimit,
      BaseBlockRewardsPct:
        config.distributionParameters.solanaValidatorFeeParameters
          .baseBlockRewardsPct,
      PriorityBlockRewardsPct:
        config.distributionParameters.solanaValidatorFeeParameters
          .priorityBlockRewardsPct,
      InflationRewardsPct:
        config.distributionParameters.solanaValidatorFeeParameters
          .inflationRewardsPct,
      JitoTipsPct:
        config.distributionParameters.solanaValidatorFeeParameters.jitoTipsPct,
      FixedSOLAmount:
        config.distributionParameters.solanaValidatorFeeParameters
          .fixedSolAmount,
      DistributeRewardsLamports:
        config.relayParameters.distributeRewardsLamports,
      DebtWriteOffFeatureActivationEpoch:
        config.debtWriteOffFeatureActivationEpoch,
    };

    for (const field of meta.fields) {
      assertField(field, fieldMap);
    }
  });

  test("tolerates extra bytes", () => {
    const [data] = loadFixture("program_config");
    const extended = new Uint8Array(data.length + 64);
    extended.set(data);
    const config = deserializeProgramConfig(
      extended,
      DISCRIMINATOR_PROGRAM_CONFIG,
    );
    expect(config.flags).toBe(1n);
  });
});

describe("Distribution fixture", () => {
  test("deserialize", () => {
    const [data, meta] = loadFixture("distribution");
    expect(DISTRIBUTION_STRUCT_SIZE).toBe(meta.struct_size);

    const dist = deserializeDistribution(data, DISCRIMINATOR_DISTRIBUTION);

    const fieldMap: Record<string, unknown> = {
      DZEpoch: dist.dzEpoch,
      Flags: dist.flags,
      CommunityBurnRate: dist.communityBurnRate,
      BaseBlockRewardsPct:
        dist.solanaValidatorFeeParameters.baseBlockRewardsPct,
      PriorityBlockRewardsPct:
        dist.solanaValidatorFeeParameters.priorityBlockRewardsPct,
      InflationRewardsPct:
        dist.solanaValidatorFeeParameters.inflationRewardsPct,
      JitoTipsPct: dist.solanaValidatorFeeParameters.jitoTipsPct,
      FixedSOLAmount: dist.solanaValidatorFeeParameters.fixedSolAmount,
      TotalSolanaValidators: dist.totalSolanaValidators,
      SolanaValidatorPaymentsCount: dist.solanaValidatorPaymentsCount,
      TotalSolanaValidatorDebt: dist.totalSolanaValidatorDebt,
      CollectedSolanaValidatorPayments: dist.collectedSolanaValidatorPayments,
      TotalContributors: dist.totalContributors,
      DistributedRewardsCount: dist.distributedRewardsCount,
      CollectedPrepaid2ZPayments: dist.collectedPrepaid2zPayments,
      Collected2ZConvertedFromSOL: dist.collected2zConvertedFromSol,
      UncollectibleSOLDebt: dist.uncollectibleSolDebt,
      Distributed2ZAmount: dist.distributed2zAmount,
      Burned2ZAmount: dist.burned2zAmount,
      SolanaValidatorWriteOffCount: dist.solanaValidatorWriteOffCount,
    };

    for (const field of meta.fields) {
      assertField(field, fieldMap);
    }
  });
});

describe("Journal fixture", () => {
  test("deserialize", () => {
    const [data, meta] = loadFixture("journal");
    expect(JOURNAL_STRUCT_SIZE).toBe(meta.struct_size);

    const journal = deserializeJournal(data, DISCRIMINATOR_JOURNAL);

    const fieldMap: Record<string, unknown> = {
      BumpSeed: journal.bumpSeed,
      TotalSOLBalance: journal.totalSolBalance,
      Total2ZBalance: journal.total2zBalance,
      Swap2ZDestinationBalance: journal.swap2zDestinationBalance,
      SwappedSOLAmount: journal.swappedSolAmount,
      NextDZEpochToSweepTokens: journal.nextDzEpochToSweepTokens,
    };

    for (const field of meta.fields) {
      assertField(field, fieldMap);
    }
  });
});

describe("SolanaValidatorDeposit fixture", () => {
  test("deserialize", () => {
    const [data, meta] = loadFixture("solana_validator_deposit");
    expect(SOLANA_VALIDATOR_DEPOSIT_STRUCT_SIZE).toBe(meta.struct_size);

    const deposit = deserializeSolanaValidatorDeposit(
      data,
      DISCRIMINATOR_SOLANA_VALIDATOR_DEPOSIT,
    );

    const fieldMap: Record<string, unknown> = {
      NodeID: deposit.nodeId,
      WrittenOffSOLDebt: deposit.writtenOffSolDebt,
    };

    for (const field of meta.fields) {
      assertField(field, fieldMap);
    }
  });
});

describe("ContributorRewards fixture", () => {
  test("deserialize", () => {
    const [data, meta] = loadFixture("contributor_rewards");
    expect(CONTRIBUTOR_REWARDS_STRUCT_SIZE).toBe(meta.struct_size);

    const rewards = deserializeContributorRewards(
      data,
      DISCRIMINATOR_CONTRIBUTOR_REWARDS,
    );

    const fieldMap: Record<string, unknown> = {
      RewardsManagerKey: rewards.rewardsManagerKey,
      ServiceKey: rewards.serviceKey,
      Flags: rewards.flags,
    };

    for (const field of meta.fields) {
      assertField(field, fieldMap);
    }
  });
});
