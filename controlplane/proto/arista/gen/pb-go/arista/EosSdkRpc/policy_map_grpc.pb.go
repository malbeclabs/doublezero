// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.6
// source: policy_map.proto

package EosSdkRpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// PolicyMapMgrServiceClient is the client API for PolicyMapMgrService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PolicyMapMgrServiceClient interface {
	// *
	// Subscription to monitor changes on a specified policy map. This request
	// stays active until the client cancels or the server shuts down.
	//
	// EosSdk reference: eos::policy_map_handler (class)
	Watch(ctx context.Context, in *PolicyMapWatchRequest, opts ...grpc.CallOption) (PolicyMapMgrService_WatchClient, error)
	// *
	// Initiates a policy map resync process. Starts a blank configuration to be
	// applied once resync_complete is called.
	//
	// EosSdk reference: eos::policy_map_mgr::resync_init
	ResyncInit(ctx context.Context, in *PolicyMapResyncInitRequest, opts ...grpc.CallOption) (*PolicyMapResyncInitResponse, error)
	// *
	// Ends the current policy map resync process.
	//
	// EosSdk reference: eos::policy_map_mgr::resync_complete
	ResyncComplete(ctx context.Context, in *PolicyMapResyncCompleteRequest, opts ...grpc.CallOption) (*PolicyMapResyncCompleteResponse, error)
	// *
	// Queries whether the specified policy map is configured or not.
	//
	// EosSdk reference: eos::policy_map_mgr::exists
	Exists(ctx context.Context, in *PolicyMapExistsRequest, opts ...grpc.CallOption) (*PolicyMapExistsResponse, error)
	// *
	// Queries a policy map given its key.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map
	PolicyMap(ctx context.Context, in *PolicyMapRequest, opts ...grpc.CallOption) (*PolicyMapResponse, error)
	// *
	// Creates or updates a policy map.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_is
	PolicyMapIs(ctx context.Context, in *PolicyMapIsRequest, opts ...grpc.CallOption) (*PolicyMapIsResponse, error)
	// *
	// Creates or updates multiple policy maps in a single call.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_is
	BulkPolicyMapIs(ctx context.Context, in *BulkPolicyMapIsRequest, opts ...grpc.CallOption) (*BulkPolicyMapIsResponse, error)
	// *
	// Deletes a policy map.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_del
	PolicyMapDel(ctx context.Context, in *PolicyMapDelRequest, opts ...grpc.CallOption) (*PolicyMapDelResponse, error)
	// *
	// Deletes multiple policy maps in a single call.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_del
	BulkPolicyMapDel(ctx context.Context, in *BulkPolicyMapDelRequest, opts ...grpc.CallOption) (*BulkPolicyMapDelResponse, error)
	// *
	// Returns a list of the keys of the configured policy maps for a policy feature.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_iter
	PolicyMaps(ctx context.Context, in *PolicyMapsRequest, opts ...grpc.CallOption) (PolicyMapMgrService_PolicyMapsClient, error)
	// *
	// Applies or unapplies a policy map on the given interface and direction.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_apply
	PolicyMapApply(ctx context.Context, in *PolicyMapApplyRequest, opts ...grpc.CallOption) (*PolicyMapApplyResponse, error)
	// *
	// Applies or unapplies multiple policy maps on the given interfaces and directions
	// in a single call.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_apply
	BulkPolicyMapApply(ctx context.Context, in *BulkPolicyMapApplyRequest, opts ...grpc.CallOption) (*BulkPolicyMapApplyResponse, error)
	// *
	// Returns a list of the policy maps in hardware for a policy feature.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_hw_status_iter
	PolicyMapHwStatuses(ctx context.Context, in *PolicyMapHwStatusesRequest, opts ...grpc.CallOption) (PolicyMapMgrService_PolicyMapHwStatusesClient, error)
	// *
	// Queries the hardware status for a specified policy map.
	//
	// EosSdk reference: eos::policy_map_mgr::hw_status
	HwStatus(ctx context.Context, in *PolicyMapHwStatusRequest, opts ...grpc.CallOption) (*PolicyMapHwStatusResponse, error)
	// *
	// Queries whether the specified traffic policy is configured or not.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_exists
	TrafficPolicyExists(ctx context.Context, in *TrafficPolicyExistsRequest, opts ...grpc.CallOption) (*TrafficPolicyExistsResponse, error)
	// *
	// Queries a traffic policy given its key.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy
	TrafficPolicy(ctx context.Context, in *TrafficPolicyRequest, opts ...grpc.CallOption) (*TrafficPolicyResponse, error)
	// *
	// Creates or updates a traffic policy.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_is
	TrafficPolicyIs(ctx context.Context, in *TrafficPolicyIsRequest, opts ...grpc.CallOption) (*TrafficPolicyIsResponse, error)
	// *
	// Creates or updates multiple traffic policies in a single call.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_is
	BulkTrafficPolicyIs(ctx context.Context, in *BulkTrafficPolicyIsRequest, opts ...grpc.CallOption) (*BulkTrafficPolicyIsResponse, error)
	// *
	// Deletes a traffic policy.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_del
	TrafficPolicyDel(ctx context.Context, in *TrafficPolicyDelRequest, opts ...grpc.CallOption) (*TrafficPolicyDelResponse, error)
	// *
	// Deletes multiple traffic policies in a single call.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_del
	BulkTrafficPolicyDel(ctx context.Context, in *BulkTrafficPolicyDelRequest, opts ...grpc.CallOption) (*BulkTrafficPolicyDelResponse, error)
	// *
	// Returns a list of the keys of the configured traffic policies.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_iter
	TrafficPolicies(ctx context.Context, in *TrafficPoliciesRequest, opts ...grpc.CallOption) (PolicyMapMgrService_TrafficPoliciesClient, error)
	// *
	// Applies or unapplies a traffic policy on the given interface and direction.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_apply
	TrafficPolicyApply(ctx context.Context, in *TrafficPolicyApplyRequest, opts ...grpc.CallOption) (*TrafficPolicyApplyResponse, error)
	// *
	// Applies or unapplies multiple traffic policies on the given interfaces and
	// directions in a single call.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_apply
	BulkTrafficPolicyApply(ctx context.Context, in *BulkTrafficPolicyApplyRequest, opts ...grpc.CallOption) (*BulkTrafficPolicyApplyResponse, error)
}

type policyMapMgrServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPolicyMapMgrServiceClient(cc grpc.ClientConnInterface) PolicyMapMgrServiceClient {
	return &policyMapMgrServiceClient{cc}
}

func (c *policyMapMgrServiceClient) Watch(ctx context.Context, in *PolicyMapWatchRequest, opts ...grpc.CallOption) (PolicyMapMgrService_WatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &PolicyMapMgrService_ServiceDesc.Streams[0], "/eos.remote.PolicyMapMgrService/watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &policyMapMgrServiceWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PolicyMapMgrService_WatchClient interface {
	Recv() (*PolicyMapWatchResponse, error)
	grpc.ClientStream
}

type policyMapMgrServiceWatchClient struct {
	grpc.ClientStream
}

func (x *policyMapMgrServiceWatchClient) Recv() (*PolicyMapWatchResponse, error) {
	m := new(PolicyMapWatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *policyMapMgrServiceClient) ResyncInit(ctx context.Context, in *PolicyMapResyncInitRequest, opts ...grpc.CallOption) (*PolicyMapResyncInitResponse, error) {
	out := new(PolicyMapResyncInitResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/resync_init", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) ResyncComplete(ctx context.Context, in *PolicyMapResyncCompleteRequest, opts ...grpc.CallOption) (*PolicyMapResyncCompleteResponse, error) {
	out := new(PolicyMapResyncCompleteResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/resync_complete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) Exists(ctx context.Context, in *PolicyMapExistsRequest, opts ...grpc.CallOption) (*PolicyMapExistsResponse, error) {
	out := new(PolicyMapExistsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) PolicyMap(ctx context.Context, in *PolicyMapRequest, opts ...grpc.CallOption) (*PolicyMapResponse, error) {
	out := new(PolicyMapResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/policy_map", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) PolicyMapIs(ctx context.Context, in *PolicyMapIsRequest, opts ...grpc.CallOption) (*PolicyMapIsResponse, error) {
	out := new(PolicyMapIsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/policy_map_is", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) BulkPolicyMapIs(ctx context.Context, in *BulkPolicyMapIsRequest, opts ...grpc.CallOption) (*BulkPolicyMapIsResponse, error) {
	out := new(BulkPolicyMapIsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/bulk_policy_map_is", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) PolicyMapDel(ctx context.Context, in *PolicyMapDelRequest, opts ...grpc.CallOption) (*PolicyMapDelResponse, error) {
	out := new(PolicyMapDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/policy_map_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) BulkPolicyMapDel(ctx context.Context, in *BulkPolicyMapDelRequest, opts ...grpc.CallOption) (*BulkPolicyMapDelResponse, error) {
	out := new(BulkPolicyMapDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/bulk_policy_map_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) PolicyMaps(ctx context.Context, in *PolicyMapsRequest, opts ...grpc.CallOption) (PolicyMapMgrService_PolicyMapsClient, error) {
	stream, err := c.cc.NewStream(ctx, &PolicyMapMgrService_ServiceDesc.Streams[1], "/eos.remote.PolicyMapMgrService/policy_maps", opts...)
	if err != nil {
		return nil, err
	}
	x := &policyMapMgrServicePolicyMapsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PolicyMapMgrService_PolicyMapsClient interface {
	Recv() (*PolicyMapsResponse, error)
	grpc.ClientStream
}

type policyMapMgrServicePolicyMapsClient struct {
	grpc.ClientStream
}

func (x *policyMapMgrServicePolicyMapsClient) Recv() (*PolicyMapsResponse, error) {
	m := new(PolicyMapsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *policyMapMgrServiceClient) PolicyMapApply(ctx context.Context, in *PolicyMapApplyRequest, opts ...grpc.CallOption) (*PolicyMapApplyResponse, error) {
	out := new(PolicyMapApplyResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/policy_map_apply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) BulkPolicyMapApply(ctx context.Context, in *BulkPolicyMapApplyRequest, opts ...grpc.CallOption) (*BulkPolicyMapApplyResponse, error) {
	out := new(BulkPolicyMapApplyResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/bulk_policy_map_apply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) PolicyMapHwStatuses(ctx context.Context, in *PolicyMapHwStatusesRequest, opts ...grpc.CallOption) (PolicyMapMgrService_PolicyMapHwStatusesClient, error) {
	stream, err := c.cc.NewStream(ctx, &PolicyMapMgrService_ServiceDesc.Streams[2], "/eos.remote.PolicyMapMgrService/policy_map_hw_statuses", opts...)
	if err != nil {
		return nil, err
	}
	x := &policyMapMgrServicePolicyMapHwStatusesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PolicyMapMgrService_PolicyMapHwStatusesClient interface {
	Recv() (*PolicyMapHwStatusesResponse, error)
	grpc.ClientStream
}

type policyMapMgrServicePolicyMapHwStatusesClient struct {
	grpc.ClientStream
}

func (x *policyMapMgrServicePolicyMapHwStatusesClient) Recv() (*PolicyMapHwStatusesResponse, error) {
	m := new(PolicyMapHwStatusesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *policyMapMgrServiceClient) HwStatus(ctx context.Context, in *PolicyMapHwStatusRequest, opts ...grpc.CallOption) (*PolicyMapHwStatusResponse, error) {
	out := new(PolicyMapHwStatusResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/hw_status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) TrafficPolicyExists(ctx context.Context, in *TrafficPolicyExistsRequest, opts ...grpc.CallOption) (*TrafficPolicyExistsResponse, error) {
	out := new(TrafficPolicyExistsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/traffic_policy_exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) TrafficPolicy(ctx context.Context, in *TrafficPolicyRequest, opts ...grpc.CallOption) (*TrafficPolicyResponse, error) {
	out := new(TrafficPolicyResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/traffic_policy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) TrafficPolicyIs(ctx context.Context, in *TrafficPolicyIsRequest, opts ...grpc.CallOption) (*TrafficPolicyIsResponse, error) {
	out := new(TrafficPolicyIsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/traffic_policy_is", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) BulkTrafficPolicyIs(ctx context.Context, in *BulkTrafficPolicyIsRequest, opts ...grpc.CallOption) (*BulkTrafficPolicyIsResponse, error) {
	out := new(BulkTrafficPolicyIsResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/bulk_traffic_policy_is", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) TrafficPolicyDel(ctx context.Context, in *TrafficPolicyDelRequest, opts ...grpc.CallOption) (*TrafficPolicyDelResponse, error) {
	out := new(TrafficPolicyDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/traffic_policy_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) BulkTrafficPolicyDel(ctx context.Context, in *BulkTrafficPolicyDelRequest, opts ...grpc.CallOption) (*BulkTrafficPolicyDelResponse, error) {
	out := new(BulkTrafficPolicyDelResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/bulk_traffic_policy_del", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) TrafficPolicies(ctx context.Context, in *TrafficPoliciesRequest, opts ...grpc.CallOption) (PolicyMapMgrService_TrafficPoliciesClient, error) {
	stream, err := c.cc.NewStream(ctx, &PolicyMapMgrService_ServiceDesc.Streams[3], "/eos.remote.PolicyMapMgrService/traffic_policies", opts...)
	if err != nil {
		return nil, err
	}
	x := &policyMapMgrServiceTrafficPoliciesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type PolicyMapMgrService_TrafficPoliciesClient interface {
	Recv() (*TrafficPoliciesResponse, error)
	grpc.ClientStream
}

type policyMapMgrServiceTrafficPoliciesClient struct {
	grpc.ClientStream
}

func (x *policyMapMgrServiceTrafficPoliciesClient) Recv() (*TrafficPoliciesResponse, error) {
	m := new(TrafficPoliciesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *policyMapMgrServiceClient) TrafficPolicyApply(ctx context.Context, in *TrafficPolicyApplyRequest, opts ...grpc.CallOption) (*TrafficPolicyApplyResponse, error) {
	out := new(TrafficPolicyApplyResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/traffic_policy_apply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *policyMapMgrServiceClient) BulkTrafficPolicyApply(ctx context.Context, in *BulkTrafficPolicyApplyRequest, opts ...grpc.CallOption) (*BulkTrafficPolicyApplyResponse, error) {
	out := new(BulkTrafficPolicyApplyResponse)
	err := c.cc.Invoke(ctx, "/eos.remote.PolicyMapMgrService/bulk_traffic_policy_apply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PolicyMapMgrServiceServer is the server API for PolicyMapMgrService service.
// All implementations should embed UnimplementedPolicyMapMgrServiceServer
// for forward compatibility
type PolicyMapMgrServiceServer interface {
	// *
	// Subscription to monitor changes on a specified policy map. This request
	// stays active until the client cancels or the server shuts down.
	//
	// EosSdk reference: eos::policy_map_handler (class)
	Watch(*PolicyMapWatchRequest, PolicyMapMgrService_WatchServer) error
	// *
	// Initiates a policy map resync process. Starts a blank configuration to be
	// applied once resync_complete is called.
	//
	// EosSdk reference: eos::policy_map_mgr::resync_init
	ResyncInit(context.Context, *PolicyMapResyncInitRequest) (*PolicyMapResyncInitResponse, error)
	// *
	// Ends the current policy map resync process.
	//
	// EosSdk reference: eos::policy_map_mgr::resync_complete
	ResyncComplete(context.Context, *PolicyMapResyncCompleteRequest) (*PolicyMapResyncCompleteResponse, error)
	// *
	// Queries whether the specified policy map is configured or not.
	//
	// EosSdk reference: eos::policy_map_mgr::exists
	Exists(context.Context, *PolicyMapExistsRequest) (*PolicyMapExistsResponse, error)
	// *
	// Queries a policy map given its key.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map
	PolicyMap(context.Context, *PolicyMapRequest) (*PolicyMapResponse, error)
	// *
	// Creates or updates a policy map.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_is
	PolicyMapIs(context.Context, *PolicyMapIsRequest) (*PolicyMapIsResponse, error)
	// *
	// Creates or updates multiple policy maps in a single call.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_is
	BulkPolicyMapIs(context.Context, *BulkPolicyMapIsRequest) (*BulkPolicyMapIsResponse, error)
	// *
	// Deletes a policy map.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_del
	PolicyMapDel(context.Context, *PolicyMapDelRequest) (*PolicyMapDelResponse, error)
	// *
	// Deletes multiple policy maps in a single call.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_del
	BulkPolicyMapDel(context.Context, *BulkPolicyMapDelRequest) (*BulkPolicyMapDelResponse, error)
	// *
	// Returns a list of the keys of the configured policy maps for a policy feature.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_iter
	PolicyMaps(*PolicyMapsRequest, PolicyMapMgrService_PolicyMapsServer) error
	// *
	// Applies or unapplies a policy map on the given interface and direction.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_apply
	PolicyMapApply(context.Context, *PolicyMapApplyRequest) (*PolicyMapApplyResponse, error)
	// *
	// Applies or unapplies multiple policy maps on the given interfaces and directions
	// in a single call.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_apply
	BulkPolicyMapApply(context.Context, *BulkPolicyMapApplyRequest) (*BulkPolicyMapApplyResponse, error)
	// *
	// Returns a list of the policy maps in hardware for a policy feature.
	//
	// EosSdk reference: eos::policy_map_mgr::policy_map_hw_status_iter
	PolicyMapHwStatuses(*PolicyMapHwStatusesRequest, PolicyMapMgrService_PolicyMapHwStatusesServer) error
	// *
	// Queries the hardware status for a specified policy map.
	//
	// EosSdk reference: eos::policy_map_mgr::hw_status
	HwStatus(context.Context, *PolicyMapHwStatusRequest) (*PolicyMapHwStatusResponse, error)
	// *
	// Queries whether the specified traffic policy is configured or not.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_exists
	TrafficPolicyExists(context.Context, *TrafficPolicyExistsRequest) (*TrafficPolicyExistsResponse, error)
	// *
	// Queries a traffic policy given its key.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy
	TrafficPolicy(context.Context, *TrafficPolicyRequest) (*TrafficPolicyResponse, error)
	// *
	// Creates or updates a traffic policy.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_is
	TrafficPolicyIs(context.Context, *TrafficPolicyIsRequest) (*TrafficPolicyIsResponse, error)
	// *
	// Creates or updates multiple traffic policies in a single call.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_is
	BulkTrafficPolicyIs(context.Context, *BulkTrafficPolicyIsRequest) (*BulkTrafficPolicyIsResponse, error)
	// *
	// Deletes a traffic policy.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_del
	TrafficPolicyDel(context.Context, *TrafficPolicyDelRequest) (*TrafficPolicyDelResponse, error)
	// *
	// Deletes multiple traffic policies in a single call.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_del
	BulkTrafficPolicyDel(context.Context, *BulkTrafficPolicyDelRequest) (*BulkTrafficPolicyDelResponse, error)
	// *
	// Returns a list of the keys of the configured traffic policies.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_iter
	TrafficPolicies(*TrafficPoliciesRequest, PolicyMapMgrService_TrafficPoliciesServer) error
	// *
	// Applies or unapplies a traffic policy on the given interface and direction.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_apply
	TrafficPolicyApply(context.Context, *TrafficPolicyApplyRequest) (*TrafficPolicyApplyResponse, error)
	// *
	// Applies or unapplies multiple traffic policies on the given interfaces and
	// directions in a single call.
	//
	// EosSdk reference: eos::policy_map_mgr::traffic_policy_apply
	BulkTrafficPolicyApply(context.Context, *BulkTrafficPolicyApplyRequest) (*BulkTrafficPolicyApplyResponse, error)
}

// UnimplementedPolicyMapMgrServiceServer should be embedded to have forward compatible implementations.
type UnimplementedPolicyMapMgrServiceServer struct {
}

func (UnimplementedPolicyMapMgrServiceServer) Watch(*PolicyMapWatchRequest, PolicyMapMgrService_WatchServer) error {
	return status.Errorf(codes.Unimplemented, "method Watch not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) ResyncInit(context.Context, *PolicyMapResyncInitRequest) (*PolicyMapResyncInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResyncInit not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) ResyncComplete(context.Context, *PolicyMapResyncCompleteRequest) (*PolicyMapResyncCompleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResyncComplete not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) Exists(context.Context, *PolicyMapExistsRequest) (*PolicyMapExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exists not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) PolicyMap(context.Context, *PolicyMapRequest) (*PolicyMapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PolicyMap not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) PolicyMapIs(context.Context, *PolicyMapIsRequest) (*PolicyMapIsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PolicyMapIs not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) BulkPolicyMapIs(context.Context, *BulkPolicyMapIsRequest) (*BulkPolicyMapIsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkPolicyMapIs not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) PolicyMapDel(context.Context, *PolicyMapDelRequest) (*PolicyMapDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PolicyMapDel not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) BulkPolicyMapDel(context.Context, *BulkPolicyMapDelRequest) (*BulkPolicyMapDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkPolicyMapDel not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) PolicyMaps(*PolicyMapsRequest, PolicyMapMgrService_PolicyMapsServer) error {
	return status.Errorf(codes.Unimplemented, "method PolicyMaps not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) PolicyMapApply(context.Context, *PolicyMapApplyRequest) (*PolicyMapApplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PolicyMapApply not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) BulkPolicyMapApply(context.Context, *BulkPolicyMapApplyRequest) (*BulkPolicyMapApplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkPolicyMapApply not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) PolicyMapHwStatuses(*PolicyMapHwStatusesRequest, PolicyMapMgrService_PolicyMapHwStatusesServer) error {
	return status.Errorf(codes.Unimplemented, "method PolicyMapHwStatuses not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) HwStatus(context.Context, *PolicyMapHwStatusRequest) (*PolicyMapHwStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HwStatus not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) TrafficPolicyExists(context.Context, *TrafficPolicyExistsRequest) (*TrafficPolicyExistsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrafficPolicyExists not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) TrafficPolicy(context.Context, *TrafficPolicyRequest) (*TrafficPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrafficPolicy not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) TrafficPolicyIs(context.Context, *TrafficPolicyIsRequest) (*TrafficPolicyIsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrafficPolicyIs not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) BulkTrafficPolicyIs(context.Context, *BulkTrafficPolicyIsRequest) (*BulkTrafficPolicyIsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkTrafficPolicyIs not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) TrafficPolicyDel(context.Context, *TrafficPolicyDelRequest) (*TrafficPolicyDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrafficPolicyDel not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) BulkTrafficPolicyDel(context.Context, *BulkTrafficPolicyDelRequest) (*BulkTrafficPolicyDelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkTrafficPolicyDel not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) TrafficPolicies(*TrafficPoliciesRequest, PolicyMapMgrService_TrafficPoliciesServer) error {
	return status.Errorf(codes.Unimplemented, "method TrafficPolicies not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) TrafficPolicyApply(context.Context, *TrafficPolicyApplyRequest) (*TrafficPolicyApplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrafficPolicyApply not implemented")
}
func (UnimplementedPolicyMapMgrServiceServer) BulkTrafficPolicyApply(context.Context, *BulkTrafficPolicyApplyRequest) (*BulkTrafficPolicyApplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkTrafficPolicyApply not implemented")
}

// UnsafePolicyMapMgrServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PolicyMapMgrServiceServer will
// result in compilation errors.
type UnsafePolicyMapMgrServiceServer interface {
	mustEmbedUnimplementedPolicyMapMgrServiceServer()
}

func RegisterPolicyMapMgrServiceServer(s grpc.ServiceRegistrar, srv PolicyMapMgrServiceServer) {
	s.RegisterService(&PolicyMapMgrService_ServiceDesc, srv)
}

func _PolicyMapMgrService_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PolicyMapWatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PolicyMapMgrServiceServer).Watch(m, &policyMapMgrServiceWatchServer{stream})
}

type PolicyMapMgrService_WatchServer interface {
	Send(*PolicyMapWatchResponse) error
	grpc.ServerStream
}

type policyMapMgrServiceWatchServer struct {
	grpc.ServerStream
}

func (x *policyMapMgrServiceWatchServer) Send(m *PolicyMapWatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _PolicyMapMgrService_ResyncInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyMapResyncInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).ResyncInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/resync_init",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).ResyncInit(ctx, req.(*PolicyMapResyncInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_ResyncComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyMapResyncCompleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).ResyncComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/resync_complete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).ResyncComplete(ctx, req.(*PolicyMapResyncCompleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyMapExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).Exists(ctx, req.(*PolicyMapExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_PolicyMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).PolicyMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/policy_map",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).PolicyMap(ctx, req.(*PolicyMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_PolicyMapIs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyMapIsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).PolicyMapIs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/policy_map_is",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).PolicyMapIs(ctx, req.(*PolicyMapIsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_BulkPolicyMapIs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkPolicyMapIsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).BulkPolicyMapIs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/bulk_policy_map_is",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).BulkPolicyMapIs(ctx, req.(*BulkPolicyMapIsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_PolicyMapDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyMapDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).PolicyMapDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/policy_map_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).PolicyMapDel(ctx, req.(*PolicyMapDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_BulkPolicyMapDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkPolicyMapDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).BulkPolicyMapDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/bulk_policy_map_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).BulkPolicyMapDel(ctx, req.(*BulkPolicyMapDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_PolicyMaps_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PolicyMapsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PolicyMapMgrServiceServer).PolicyMaps(m, &policyMapMgrServicePolicyMapsServer{stream})
}

type PolicyMapMgrService_PolicyMapsServer interface {
	Send(*PolicyMapsResponse) error
	grpc.ServerStream
}

type policyMapMgrServicePolicyMapsServer struct {
	grpc.ServerStream
}

func (x *policyMapMgrServicePolicyMapsServer) Send(m *PolicyMapsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _PolicyMapMgrService_PolicyMapApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyMapApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).PolicyMapApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/policy_map_apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).PolicyMapApply(ctx, req.(*PolicyMapApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_BulkPolicyMapApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkPolicyMapApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).BulkPolicyMapApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/bulk_policy_map_apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).BulkPolicyMapApply(ctx, req.(*BulkPolicyMapApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_PolicyMapHwStatuses_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PolicyMapHwStatusesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PolicyMapMgrServiceServer).PolicyMapHwStatuses(m, &policyMapMgrServicePolicyMapHwStatusesServer{stream})
}

type PolicyMapMgrService_PolicyMapHwStatusesServer interface {
	Send(*PolicyMapHwStatusesResponse) error
	grpc.ServerStream
}

type policyMapMgrServicePolicyMapHwStatusesServer struct {
	grpc.ServerStream
}

func (x *policyMapMgrServicePolicyMapHwStatusesServer) Send(m *PolicyMapHwStatusesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _PolicyMapMgrService_HwStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PolicyMapHwStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).HwStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/hw_status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).HwStatus(ctx, req.(*PolicyMapHwStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_TrafficPolicyExists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficPolicyExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).TrafficPolicyExists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/traffic_policy_exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).TrafficPolicyExists(ctx, req.(*TrafficPolicyExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_TrafficPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).TrafficPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/traffic_policy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).TrafficPolicy(ctx, req.(*TrafficPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_TrafficPolicyIs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficPolicyIsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).TrafficPolicyIs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/traffic_policy_is",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).TrafficPolicyIs(ctx, req.(*TrafficPolicyIsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_BulkTrafficPolicyIs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkTrafficPolicyIsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).BulkTrafficPolicyIs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/bulk_traffic_policy_is",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).BulkTrafficPolicyIs(ctx, req.(*BulkTrafficPolicyIsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_TrafficPolicyDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficPolicyDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).TrafficPolicyDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/traffic_policy_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).TrafficPolicyDel(ctx, req.(*TrafficPolicyDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_BulkTrafficPolicyDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkTrafficPolicyDelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).BulkTrafficPolicyDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/bulk_traffic_policy_del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).BulkTrafficPolicyDel(ctx, req.(*BulkTrafficPolicyDelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_TrafficPolicies_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TrafficPoliciesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PolicyMapMgrServiceServer).TrafficPolicies(m, &policyMapMgrServiceTrafficPoliciesServer{stream})
}

type PolicyMapMgrService_TrafficPoliciesServer interface {
	Send(*TrafficPoliciesResponse) error
	grpc.ServerStream
}

type policyMapMgrServiceTrafficPoliciesServer struct {
	grpc.ServerStream
}

func (x *policyMapMgrServiceTrafficPoliciesServer) Send(m *TrafficPoliciesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _PolicyMapMgrService_TrafficPolicyApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrafficPolicyApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).TrafficPolicyApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/traffic_policy_apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).TrafficPolicyApply(ctx, req.(*TrafficPolicyApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PolicyMapMgrService_BulkTrafficPolicyApply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkTrafficPolicyApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PolicyMapMgrServiceServer).BulkTrafficPolicyApply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eos.remote.PolicyMapMgrService/bulk_traffic_policy_apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PolicyMapMgrServiceServer).BulkTrafficPolicyApply(ctx, req.(*BulkTrafficPolicyApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PolicyMapMgrService_ServiceDesc is the grpc.ServiceDesc for PolicyMapMgrService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PolicyMapMgrService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "eos.remote.PolicyMapMgrService",
	HandlerType: (*PolicyMapMgrServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "resync_init",
			Handler:    _PolicyMapMgrService_ResyncInit_Handler,
		},
		{
			MethodName: "resync_complete",
			Handler:    _PolicyMapMgrService_ResyncComplete_Handler,
		},
		{
			MethodName: "exists",
			Handler:    _PolicyMapMgrService_Exists_Handler,
		},
		{
			MethodName: "policy_map",
			Handler:    _PolicyMapMgrService_PolicyMap_Handler,
		},
		{
			MethodName: "policy_map_is",
			Handler:    _PolicyMapMgrService_PolicyMapIs_Handler,
		},
		{
			MethodName: "bulk_policy_map_is",
			Handler:    _PolicyMapMgrService_BulkPolicyMapIs_Handler,
		},
		{
			MethodName: "policy_map_del",
			Handler:    _PolicyMapMgrService_PolicyMapDel_Handler,
		},
		{
			MethodName: "bulk_policy_map_del",
			Handler:    _PolicyMapMgrService_BulkPolicyMapDel_Handler,
		},
		{
			MethodName: "policy_map_apply",
			Handler:    _PolicyMapMgrService_PolicyMapApply_Handler,
		},
		{
			MethodName: "bulk_policy_map_apply",
			Handler:    _PolicyMapMgrService_BulkPolicyMapApply_Handler,
		},
		{
			MethodName: "hw_status",
			Handler:    _PolicyMapMgrService_HwStatus_Handler,
		},
		{
			MethodName: "traffic_policy_exists",
			Handler:    _PolicyMapMgrService_TrafficPolicyExists_Handler,
		},
		{
			MethodName: "traffic_policy",
			Handler:    _PolicyMapMgrService_TrafficPolicy_Handler,
		},
		{
			MethodName: "traffic_policy_is",
			Handler:    _PolicyMapMgrService_TrafficPolicyIs_Handler,
		},
		{
			MethodName: "bulk_traffic_policy_is",
			Handler:    _PolicyMapMgrService_BulkTrafficPolicyIs_Handler,
		},
		{
			MethodName: "traffic_policy_del",
			Handler:    _PolicyMapMgrService_TrafficPolicyDel_Handler,
		},
		{
			MethodName: "bulk_traffic_policy_del",
			Handler:    _PolicyMapMgrService_BulkTrafficPolicyDel_Handler,
		},
		{
			MethodName: "traffic_policy_apply",
			Handler:    _PolicyMapMgrService_TrafficPolicyApply_Handler,
		},
		{
			MethodName: "bulk_traffic_policy_apply",
			Handler:    _PolicyMapMgrService_BulkTrafficPolicyApply_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "watch",
			Handler:       _PolicyMapMgrService_Watch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "policy_maps",
			Handler:       _PolicyMapMgrService_PolicyMaps_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "policy_map_hw_statuses",
			Handler:       _PolicyMapMgrService_PolicyMapHwStatuses_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "traffic_policies",
			Handler:       _PolicyMapMgrService_TrafficPolicies_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "policy_map.proto",
}
