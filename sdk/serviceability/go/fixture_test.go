package serviceability

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"runtime"
	"strconv"
	"testing"

	"github.com/gagliardetto/solana-go"
)

// These tests deserialize binary fixtures generated by the Rust fixture
// generator and verify that Go's deserialized field values match the
// expected values from the JSON sidecar files.
//
// Regenerate fixtures:
//   cd ../testdata/fixtures/generate-fixtures && cargo run

type fixtureMeta struct {
	Name        string       `json:"name"`
	AccountType int          `json:"account_type"`
	Fields      []fieldValue `json:"fields"`
}

type fieldValue struct {
	Name  string `json:"name"`
	Value string `json:"value"`
	Type  string `json:"typ"`
}

func fixturesDir() string {
	_, filename, _, _ := runtime.Caller(0)
	return filepath.Join(filepath.Dir(filename), "..", "testdata", "fixtures")
}

func loadFixture(t *testing.T, name string) ([]byte, fixtureMeta) {
	t.Helper()
	dir := fixturesDir()

	binData, err := os.ReadFile(filepath.Join(dir, name+".bin"))
	if err != nil {
		t.Fatalf("reading %s.bin: %v", name, err)
	}

	jsonData, err := os.ReadFile(filepath.Join(dir, name+".json"))
	if err != nil {
		t.Fatalf("reading %s.json: %v", name, err)
	}

	var meta fixtureMeta
	if err := json.Unmarshal(jsonData, &meta); err != nil {
		t.Fatalf("parsing %s.json: %v", name, err)
	}

	return binData, meta
}

func TestFixtureGlobalState(t *testing.T) {
	data, meta := loadFixture(t, "global_state")
	reader := NewByteReader(data)
	var gs GlobalState
	DeserializeGlobalState(reader, &gs)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":                uint8(gs.AccountType),
		"BumpSeed":                   gs.BumpSeed,
		"ContributorAirdropLamports": gs.ContributorAirdropLamports,
		"UserAirdropLamports":        gs.UserAirdropLamports,
		"ActivatorAuthorityPK":       solana.PublicKey(gs.ActivatorAuthorityPK),
		"SentinelAuthorityPK":        solana.PublicKey(gs.SentinelAuthorityPK),
		"HealthOraclePK":             solana.PublicKey(gs.HealthOraclePK),
	})
}

func TestFixtureGlobalConfig(t *testing.T) {
	data, meta := loadFixture(t, "global_config")
	reader := NewByteReader(data)
	var gc GlobalConfig
	DeserializeGlobalConfig(reader, &gc)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":      uint8(gc.AccountType),
		"Owner":            solana.PublicKey(gc.Owner),
		"BumpSeed":         gc.BumpSeed,
		"LocalASN":         gc.LocalASN,
		"RemoteASN":        gc.RemoteASN,
		"NextBGPCommunity": gc.NextBGPCommunity,
	})
}

func TestFixtureLocation(t *testing.T) {
	data, meta := loadFixture(t, "location")
	reader := NewByteReader(data)
	var loc Location
	DeserializeLocation(reader, &loc)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":    uint8(loc.AccountType),
		"Owner":          solana.PublicKey(loc.Owner),
		"BumpSeed":       loc.BumpSeed,
		"LocId":          loc.LocId,
		"Status":         uint8(loc.Status),
		"ReferenceCount": loc.ReferenceCount,
	})
}

func TestFixtureExchange(t *testing.T) {
	data, meta := loadFixture(t, "exchange")
	reader := NewByteReader(data)
	var exch Exchange
	DeserializeExchange(reader, &exch)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":    uint8(exch.AccountType),
		"Owner":          solana.PublicKey(exch.Owner),
		"BumpSeed":       exch.BumpSeed,
		"BgpCommunity":   exch.BgpCommunity,
		"Status":         uint8(exch.Status),
		"ReferenceCount": exch.ReferenceCount,
		"Device1PK":      solana.PublicKey(exch.Device1PK),
		"Device2PK":      solana.PublicKey(exch.Device2PK),
	})
}

func TestFixtureDevice(t *testing.T) {
	data, meta := loadFixture(t, "device")
	reader := NewByteReader(data)
	var dev Device
	DeserializeDevice(reader, &dev)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":        uint8(dev.AccountType),
		"Owner":              solana.PublicKey(dev.Owner),
		"Index":              dev.Index,
		"BumpSeed":           dev.BumpSeed,
		"LocationPk":         solana.PublicKey(dev.LocationPubKey),
		"ExchangePk":         solana.PublicKey(dev.ExchangePubKey),
		"DeviceType":         uint8(dev.DeviceType),
		"PublicIp":           dev.PublicIp,
		"Status":             uint8(dev.Status),
		"Code":               dev.Code,
		"MetricsPublisherPk": solana.PublicKey(dev.MetricsPublisherPubKey),
		"ContributorPk":      solana.PublicKey(dev.ContributorPubKey),
		"MgmtVrf":            dev.MgmtVrf,
		"ReferenceCount":     dev.ReferenceCount,
		"UsersCount":         dev.UsersCount,
		"MaxUsers":           dev.MaxUsers,
		"DeviceHealth":       uint8(dev.DeviceHealth),
		"DesiredStatus":      uint8(dev.DeviceDesiredStatus),
	})

	// Verify DzPrefixes
	if len(dev.DzPrefixes) != 1 {
		t.Fatalf("DzPrefixes: want len 1, got %d", len(dev.DzPrefixes))
	}
	assertEq(t, "DzPrefixes[0]", "10.10.0.0/24", formatNetworkV4(dev.DzPrefixes[0]))

	// Verify Interfaces
	if len(dev.Interfaces) != 2 {
		t.Fatalf("Interfaces: want len 2, got %d", len(dev.Interfaces))
	}

	iface0 := dev.Interfaces[0]
	assertEq(t, "Interface0Version", uint8(0), iface0.Version)
	assertEq(t, "Interface0Status", uint8(3), uint8(iface0.Status))
	assertEq(t, "Interface0Name", "Loopback0", iface0.Name)
	assertEq(t, "Interface0InterfaceType", uint8(1), uint8(iface0.InterfaceType))
	assertEq(t, "Interface0LoopbackType", uint8(1), uint8(iface0.LoopbackType))
	assertEq(t, "Interface0VlanId", uint16(0), iface0.VlanId)
	assertEq(t, "Interface0IpNet", "10.0.0.1/32", formatNetworkV4(iface0.IpNet))
	assertEq(t, "Interface0NodeSegmentIdx", uint16(100), iface0.NodeSegmentIdx)
	assertEq(t, "Interface0UserTunnelEndpoint", false, iface0.UserTunnelEndpoint)

	iface1 := dev.Interfaces[1]
	assertEq(t, "Interface1Version", uint8(1), iface1.Version)
	assertEq(t, "Interface1Status", uint8(3), uint8(iface1.Status))
	assertEq(t, "Interface1Name", "Ethernet1", iface1.Name)
	assertEq(t, "Interface1InterfaceType", uint8(2), uint8(iface1.InterfaceType))
	assertEq(t, "Interface1InterfaceCYOA", uint8(1), uint8(iface1.InterfaceCYOA))
	assertEq(t, "Interface1InterfaceDIA", uint8(1), uint8(iface1.InterfaceDIA))
	assertEq(t, "Interface1LoopbackType", uint8(0), uint8(iface1.LoopbackType))
	assertEq(t, "Interface1Bandwidth", uint64(10000000000), iface1.Bandwidth)
	assertEq(t, "Interface1Cir", uint64(5000000000), iface1.Cir)
	assertEq(t, "Interface1Mtu", uint16(9000), iface1.Mtu)
	assertEq(t, "Interface1RoutingMode", uint8(1), uint8(iface1.RoutingMode))
	assertEq(t, "Interface1VlanId", uint16(100), iface1.VlanId)
	assertEq(t, "Interface1IpNet", "172.16.0.1/30", formatNetworkV4(iface1.IpNet))
	assertEq(t, "Interface1NodeSegmentIdx", uint16(200), iface1.NodeSegmentIdx)
	assertEq(t, "Interface1UserTunnelEndpoint", true, iface1.UserTunnelEndpoint)
}

func TestFixtureLink(t *testing.T) {
	data, meta := loadFixture(t, "link")
	reader := NewByteReader(data)
	var link Link
	DeserializeLink(reader, &link)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":       uint8(link.AccountType),
		"Owner":             solana.PublicKey(link.Owner),
		"BumpSeed":          link.BumpSeed,
		"SideAPubKey":       solana.PublicKey(link.SideAPubKey),
		"SideZPubKey":       solana.PublicKey(link.SideZPubKey),
		"LinkType":          uint8(link.LinkType),
		"Bandwidth":         link.Bandwidth,
		"Mtu":               link.Mtu,
		"DelayNs":           link.DelayNs,
		"JitterNs":          link.JitterNs,
		"TunnelId":          link.TunnelId,
		"Status":            uint8(link.Status),
		"ContributorPubKey": solana.PublicKey(link.ContributorPubKey),
		"DelayOverrideNs":   link.DelayOverrideNs,
		"LinkHealth":        uint8(link.LinkHealth),
		"LinkDesiredStatus": uint8(link.LinkDesiredStatus),
	})
}

func TestFixtureUser(t *testing.T) {
	data, meta := loadFixture(t, "user")
	reader := NewByteReader(data)
	var user User
	DeserializeUser(reader, &user)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":     uint8(user.AccountType),
		"Owner":           solana.PublicKey(user.Owner),
		"BumpSeed":        user.BumpSeed,
		"UserType":        uint8(user.UserType),
		"TenantPubKey":    solana.PublicKey(user.TenantPubKey),
		"DevicePubKey":    solana.PublicKey(user.DevicePubKey),
		"CyoaType":        uint8(user.CyoaType),
		"TunnelId":        user.TunnelId,
		"Status":          uint8(user.Status),
		"ValidatorPubKey": solana.PublicKey(user.ValidatorPubKey),
	})
}

func TestFixtureMulticastGroup(t *testing.T) {
	data, meta := loadFixture(t, "multicast_group")
	reader := NewByteReader(data)
	var mg MulticastGroup
	DeserializeMulticastGroup(reader, &mg)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":     uint8(mg.AccountType),
		"Owner":           solana.PublicKey(mg.Owner),
		"BumpSeed":        mg.BumpSeed,
		"TenantPubKey":    solana.PublicKey(mg.TenantPubKey),
		"MaxBandwidth":    mg.MaxBandwidth,
		"Status":          uint8(mg.Status),
		"PublisherCount":  mg.PublisherCount,
		"SubscriberCount": mg.SubscriberCount,
	})
}

func TestFixtureContributor(t *testing.T) {
	data, meta := loadFixture(t, "contributor")
	reader := NewByteReader(data)
	var contrib Contributor
	DeserializeContributor(reader, &contrib)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":    uint8(contrib.AccountType),
		"Owner":          solana.PublicKey(contrib.Owner),
		"BumpSeed":       contrib.BumpSeed,
		"Status":         uint8(contrib.Status),
		"ReferenceCount": contrib.ReferenceCount,
		"OpsManagerPK":   solana.PublicKey(contrib.OpsManagerPK),
	})
}

func TestFixtureProgramConfig(t *testing.T) {
	data, meta := loadFixture(t, "program_config")
	reader := NewByteReader(data)
	var pc ProgramConfig
	DeserializeProgramConfig(reader, &pc)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":  uint8(pc.AccountType),
		"BumpSeed":     pc.BumpSeed,
		"VersionMajor": pc.Version.Major,
		"VersionMinor": pc.Version.Minor,
		"VersionPatch": pc.Version.Patch,
	})
}

func TestFixtureTenant(t *testing.T) {
	data, meta := loadFixture(t, "tenant")
	reader := NewByteReader(data)
	var tenant Tenant
	DeserializeTenant(reader, &tenant)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":    uint8(tenant.AccountType),
		"Owner":          solana.PublicKey(tenant.Owner),
		"BumpSeed":       tenant.BumpSeed,
		"Code":           tenant.Code,
		"VrfId":          tenant.VrfId,
		"ReferenceCount": tenant.ReferenceCount,
		"PaymentStatus":  uint8(tenant.PaymentStatus),
		"TokenAccount":   solana.PublicKey(tenant.TokenAccount),
		"MetroRouting":                 tenant.MetroRouting,
		"RouteLiveness":                tenant.RouteLiveness,
		"BillingDiscriminant":          tenant.BillingDiscriminant,
		"BillingRate":                  tenant.BillingRate,
		"BillingLastDeductionDzEpoch":  tenant.BillingLastDeductionDzEpoch,
	})
}

func TestFixtureAccessPass(t *testing.T) {
	data, meta := loadFixture(t, "access_pass")
	reader := NewByteReader(data)
	var ap AccessPass
	DeserializeAccessPass(reader, &ap)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":     uint8(ap.AccountType),
		"Owner":           solana.PublicKey(ap.Owner),
		"BumpSeed":        ap.BumpSeed,
		"AccessPassType":  uint8(ap.AccessPassTypeTag),
		"UserPayer":       solana.PublicKey(ap.UserPayer),
		"LastAccessEpoch": ap.LastAccessEpoch,
		"ConnectionCount": ap.ConnectionCount,
		"Status":          uint8(ap.Status),
		"Flags":           ap.Flags,
	})
}

func TestFixtureAccessPassValidator(t *testing.T) {
	data, meta := loadFixture(t, "access_pass_validator")
	reader := NewByteReader(data)
	var ap AccessPass
	DeserializeAccessPass(reader, &ap)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":                   uint8(ap.AccountType),
		"Owner":                         solana.PublicKey(ap.Owner),
		"BumpSeed":                      ap.BumpSeed,
		"AccessPassType":                uint8(ap.AccessPassTypeTag),
		"AccessPassTypeValidatorPubkey": solana.PublicKey(ap.AssociatedPubkey),
		"ClientIp":                      ap.ClientIp,
		"UserPayer":                     solana.PublicKey(ap.UserPayer),
		"LastAccessEpoch":               ap.LastAccessEpoch,
		"ConnectionCount":               ap.ConnectionCount,
		"Status":                        uint8(ap.Status),
		"Flags":                         ap.Flags,
	})

	// Verify MGroupPubAllowlist
	if len(ap.MGroupPubAllowlist) != 1 {
		t.Fatalf("MGroupPubAllowlist: want len 1, got %d", len(ap.MGroupPubAllowlist))
	}
	assertEq(t, "MGroupPubAllowlist[0]",
		solana.MustPublicKeyFromBase58("ByHTNjGkgHhNakbovFQmw3VGBb6e5rbnBPGk3naDV8mD"),
		solana.PublicKey(ap.MGroupPubAllowlist[0]))

	// Verify MGroupSubAllowlist
	if len(ap.MGroupSubAllowlist) != 1 {
		t.Fatalf("MGroupSubAllowlist: want len 1, got %d", len(ap.MGroupSubAllowlist))
	}
	assertEq(t, "MGroupSubAllowlist[0]",
		solana.MustPublicKeyFromBase58("C3Bs2Dzqa8C5zSinRkgDpyEVSbfQnohgmFadYytDCwRZ"),
		solana.PublicKey(ap.MGroupSubAllowlist[0]))
}

func TestFixtureResourceExtensionId(t *testing.T) {
	data, meta := loadFixture(t, "resource_extension_id")
	reader := NewByteReader(data)
	var ext ResourceExtension
	DeserializeResourceExtension(reader, &ext)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":    uint8(ext.AccountType),
		"Owner":          solana.PublicKey(ext.Owner),
		"BumpSeed":       ext.BumpSeed,
		"AssociatedWith": solana.PublicKey(ext.AssociatedWith),
		"AllocatorType":  uint8(ext.Allocator.Type),
	})

	// Verify this is an ID allocator
	if ext.Allocator.Type != AllocatorTypeId {
		t.Fatalf("AllocatorType: want %d (Id), got %d", AllocatorTypeId, ext.Allocator.Type)
	}
	if ext.Allocator.IdAllocator == nil {
		t.Fatal("IdAllocator should not be nil")
	}

	assertFields(t, meta.Fields, map[string]any{
		"RangeStart": ext.Allocator.IdAllocator.RangeStart,
		"RangeEnd":   ext.Allocator.IdAllocator.RangeEnd,
	})

	// Verify capacity and allocation counting from bitmap
	assertEq(t, "TotalCapacity", 64, ext.TotalCapacity())
	assertEq(t, "AllocatedCount", 5, ext.AllocatedCount())
	assertEq(t, "AvailableCount", 59, ext.AvailableCount())
}

func TestFixtureResourceExtensionIp(t *testing.T) {
	data, meta := loadFixture(t, "resource_extension_ip")
	reader := NewByteReader(data)
	var ext ResourceExtension
	DeserializeResourceExtension(reader, &ext)

	assertFields(t, meta.Fields, map[string]any{
		"AccountType":    uint8(ext.AccountType),
		"Owner":          solana.PublicKey(ext.Owner),
		"BumpSeed":       ext.BumpSeed,
		"AssociatedWith": solana.PublicKey(ext.AssociatedWith),
		"AllocatorType":  uint8(ext.Allocator.Type),
	})

	// Verify this is an IP allocator
	if ext.Allocator.Type != AllocatorTypeIp {
		t.Fatalf("AllocatorType: want %d (Ip), got %d", AllocatorTypeIp, ext.Allocator.Type)
	}
	if ext.Allocator.IpAllocator == nil {
		t.Fatal("IpAllocator should not be nil")
	}

	// Verify BaseNet
	assertEq(t, "BaseNet", "10.100.0.0/24", ext.BaseNetString())

	// Verify capacity and allocation counting from bitmap
	assertEq(t, "TotalCapacity", 256, ext.TotalCapacity())
	assertEq(t, "AllocatedCount", 4, ext.AllocatedCount())
	assertEq(t, "AvailableCount", 252, ext.AvailableCount())
}

func assertFields(t *testing.T, expected []fieldValue, got map[string]any) {
	t.Helper()
	for _, f := range expected {
		val, ok := got[f.Name]
		if !ok {
			continue
		}
		assertField(t, f, val)
	}
}

func assertField(t *testing.T, f fieldValue, got any) {
	t.Helper()
	switch f.Type {
	case "u8":
		want, _ := strconv.ParseUint(f.Value, 10, 8)
		assertEq(t, f.Name, uint8(want), got)
	case "u16":
		want, _ := strconv.ParseUint(f.Value, 10, 16)
		assertEq(t, f.Name, uint16(want), got)
	case "u32":
		want, _ := strconv.ParseUint(f.Value, 10, 32)
		assertEq(t, f.Name, uint32(want), got)
	case "u64":
		want, _ := strconv.ParseUint(f.Value, 10, 64)
		assertEq(t, f.Name, uint64(want), got)
	case "pubkey":
		want := solana.MustPublicKeyFromBase58(f.Value)
		assertEq(t, f.Name, want, got)
	case "string":
		assertEq(t, f.Name, f.Value, got)
	case "bool":
		want := f.Value == "true"
		assertEq(t, f.Name, want, got)
	case "ipv4":
		ip := got.([4]uint8)
		gotStr := fmt.Sprintf("%d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3])
		assertEq(t, f.Name, f.Value, gotStr)
	case "networkv4":
		net := got.([5]uint8)
		gotStr := formatNetworkV4(net)
		assertEq(t, f.Name, f.Value, gotStr)
	case "u128":
		want, _ := strconv.ParseUint(f.Value, 10, 64)
		assertEq(t, f.Name, Uint128{Low: want, High: 0}, got)
	default:
		t.Errorf("field %s: unknown type %q", f.Name, f.Type)
	}
}

func formatNetworkV4(n [5]uint8) string {
	return fmt.Sprintf("%d.%d.%d.%d/%d", n[0], n[1], n[2], n[3], n[4])
}

func assertEq(t *testing.T, name string, want, got any) {
	t.Helper()
	if !reflect.DeepEqual(want, got) {
		t.Errorf("%s: want %v, got %v", name, want, fmt.Sprintf("%v", got))
	}
}
