
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/malbeclabs/doublezero/controlplane/controller/cmd/controller/main.go (0.0%)</option>
				
				<option value="file1">github.com/malbeclabs/doublezero/controlplane/controller/internal/controller/metrics.go (100.0%)</option>
				
				<option value="file2">github.com/malbeclabs/doublezero/controlplane/controller/internal/controller/models.go (90.0%)</option>
				
				<option value="file3">github.com/malbeclabs/doublezero/controlplane/controller/internal/controller/render.go (71.4%)</option>
				
				<option value="file4">github.com/malbeclabs/doublezero/controlplane/controller/internal/controller/server.go (79.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "errors"
        "flag"
        "fmt"
        "log/slog"
        "net"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "text/tabwriter"
        "time"

        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        "github.com/malbeclabs/doublezero/controlplane/controller/internal/controller"
        pb "github.com/malbeclabs/doublezero/controlplane/proto/controller/gen/pb-go"
)

var (
        // set by LDFLAGS
        version = "dev"
        commit  = "none"
        date    = "unknown"
)

type Runner interface {
        Init([]string) error
        Run() error
        Name() string
        Fs() *flag.FlagSet
        Description() string
}

func NewAgentCommand() *AgentCommand <span class="cov0" title="0">{
        a := &amp;AgentCommand{
                fs:          flag.NewFlagSet("agent", flag.ExitOnError),
                description: "command set for interacting with controller",
        }
        a.fs.StringVar(&amp;a.pubkey, "device-pubkey", "", "pubkey of device which to fetch config")
        a.fs.StringVar(&amp;a.controllerAddr, "controller-addr", "localhost", "listening address of controller")
        a.fs.StringVar(&amp;a.controllerPort, "controller-port", "443", "listening port of controller")
        a.fs.StringVar(&amp;a.unknownPeers, "unknown-peers", "", "comma separated list of unknown peers to remove from config")
        return a
}</span>

type AgentCommand struct {
        fs             *flag.FlagSet
        description    string
        pubkey         string
        controllerAddr string
        controllerPort string
        unknownPeers   string
}

func (a *AgentCommand) Fs() *flag.FlagSet <span class="cov0" title="0">{
        return a.fs
}</span>

func (a *AgentCommand) Name() string <span class="cov0" title="0">{
        return a.fs.Name()
}</span>

func (a *AgentCommand) Description() string <span class="cov0" title="0">{
        return a.description
}</span>

func (a *AgentCommand) Init(args []string) error <span class="cov0" title="0">{
        return a.fs.Parse(args)
}</span>

func (a *AgentCommand) Run() error <span class="cov0" title="0">{
        target := net.JoinHostPort(a.controllerAddr, a.controllerPort)

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        opts := []grpc.DialOption{
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        }
        conn, err := grpc.NewClient(target, opts...)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("error creating controller client", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer conn.Close()
        defer cancel()

        unknownPeers := []string{}
        if a.unknownPeers != "" </span><span class="cov0" title="0">{
                unknownPeers = append(unknownPeers, strings.Split(a.unknownPeers, ",")...)
        }</span>
        <span class="cov0" title="0">agent := pb.NewControllerClient(conn)
        got, err := agent.GetConfig(ctx, &amp;pb.ConfigRequest{Pubkey: a.pubkey, BgpPeers: unknownPeers})
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("error while fetching config", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Println(got.Config)
        return nil</span>
}

func NewControllerCommand() *ControllerCommand <span class="cov0" title="0">{
        c := &amp;ControllerCommand{
                fs:          flag.NewFlagSet("start", flag.ExitOnError),
                description: "command set for starting controller",
        }
        c.fs.StringVar(&amp;c.listenAddr, "listen-addr", "localhost", "listening address for controller grpc server")
        c.fs.StringVar(&amp;c.listenPort, "listen-port", "443", "listening port for controller grpc server")
        c.fs.StringVar(&amp;c.programId, "program-id", "", "smartcontract program id to monitor")
        c.fs.StringVar(&amp;c.rpcEndpoint, "solana-rpc-endpoint", "", "override solana rpc endpoint (default: devnet)")
        c.fs.BoolVar(&amp;c.noHardware, "no-hardware", false, "exclude config commands that will fail when not running on the real hardware")
        c.fs.BoolVar(&amp;c.showVersion, "version", false, "show version information and exit")
        return c
}</span>

type ControllerCommand struct {
        fs          *flag.FlagSet
        description string
        listenAddr  string
        listenPort  string
        programId   string
        rpcEndpoint string
        noHardware  bool
        showVersion bool
}

func (c *ControllerCommand) Fs() *flag.FlagSet <span class="cov0" title="0">{
        return c.fs
}</span>

func (c *ControllerCommand) Name() string <span class="cov0" title="0">{
        return c.fs.Name()
}</span>

func (c *ControllerCommand) Description() string <span class="cov0" title="0">{
        return c.description
}</span>

func (c *ControllerCommand) Init(args []string) error <span class="cov0" title="0">{
        return c.fs.Parse(args)
}</span>

func (c *ControllerCommand) Run() error <span class="cov0" title="0">{
        if c.showVersion </span><span class="cov0" title="0">{
                fmt.Printf("version: %s, commit: %s, date: %s\n", version, commit, date)
                os.Exit(0)
        }</span>

        // set build info prometheus metric
        <span class="cov0" title="0">controller.BuildInfo.WithLabelValues(version, commit, date).Set(1)

        // start controller
        ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
        defer stop()

        options := []controller.Option{}
        if c.programId != "" </span><span class="cov0" title="0">{
                options = append(options, controller.WithProgramId(c.programId))
        }</span>

        <span class="cov0" title="0">if c.rpcEndpoint != "" </span><span class="cov0" title="0">{
                options = append(options, controller.WithRpcEndpoint(c.rpcEndpoint))
        }</span>

        <span class="cov0" title="0">if c.noHardware </span><span class="cov0" title="0">{
                options = append(options, controller.WithNoHardware())
        }</span>

        <span class="cov0" title="0">lis, err := net.Listen("tcp", net.JoinHostPort(c.listenAddr, c.listenPort))
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("failed to listen", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">options = append(options, controller.WithListener(lis))
        control, err := controller.NewController(options...)
        if err != nil </span><span class="cov0" title="0">{
                slog.Error("error creating controller", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">slog.Log(ctx, slog.LevelInfo, fmt.Sprintf("starting controller on %s", net.JoinHostPort(c.listenAddr, c.listenPort)))
        if err := control.Run(ctx); err != nil </span><span class="cov0" title="0">{
                slog.Error("runtime error", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func root(args []string) error <span class="cov0" title="0">{
        cmds := []Runner{
                NewAgentCommand(),
                NewControllerCommand(),
        }

        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "\nUsage:\n\n")
                w := tabwriter.NewWriter(os.Stderr, 0, 0, 3, ' ', 0)
                for _, cmd := range cmds </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "\t%s\t%s\t\n", cmd.Name(), cmd.Description())
                }</span>
                <span class="cov0" title="0">w.Flush()</span>
        }

        <span class="cov0" title="0">if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return errors.New("error: you must pass a sub-command")
        }</span>

        <span class="cov0" title="0">subcommand := os.Args[1]

        for _, cmd := range cmds </span><span class="cov0" title="0">{
                if cmd.Name() == subcommand </span><span class="cov0" title="0">{
                        cmd.Init(os.Args[2:]) // nolint:all
                        return cmd.Run()
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("unknown subcommand: %s", subcommand)</span>
}

func main() <span class="cov0" title="0">{

        opts := &amp;slog.HandlerOptions{}
        logger := slog.New(slog.NewJSONHandler(os.Stdout, opts))
        slog.SetDefault(logger)

        if err := root(os.Args[1:]); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                flag.Usage()
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">flag.Parse()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package controller

import (
        "github.com/prometheus/client_golang/prometheus"
)

var (
        BuildInfo = prometheus.NewGaugeVec(prometheus.GaugeOpts{
                Name: "controller_build_info",
                Help: "Build information of the agent",
        },
                []string{"version", "commit", "date"},
        )

        // gRPC metrics
        getConfigPubkeyErrors = prometheus.NewCounterVec(prometheus.CounterOpts{
                Name: "controller_grpc_getconfig_pubkey_errors_total",
                Help: "The total number of missing pubkeys in cache",
        },
                []string{"pubkey"},
        )

        getConfigRenderErrors = prometheus.NewCounterVec(prometheus.CounterOpts{
                Name: "controller_grpc_getconfig_render_errors_total",
                Help: "The total number of failed config renderings",
        },
                []string{"pubkey"},
        )

        getConfigOps = prometheus.NewCounterVec(prometheus.CounterOpts{
                Name: "controller_grpc_getconfig_requests_total",
                Help: "The total number of getconfig requests",
        },
                []string{"pubkey"},
        )

        // cache update metrics
        cacheUpdateErrors = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "controller_cache_update_errors_total",
                Help: "The total number of cache update errors",
        })

        cacheUpdateFetchErrors = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "controller_cache_update_fetch_errors_total",
                Help: "The total number of cache update errors from fetching on-chain data",
        })

        cacheUpdateOps = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "controller_cache_update_ops_total",
                Help: "The total number of cache update ops",
        })
)

func init() <span class="cov8" title="1">{
        // build info
        prometheus.MustRegister(BuildInfo)

        // gRPC metrics
        prometheus.MustRegister(getConfigPubkeyErrors)
        prometheus.MustRegister(getConfigRenderErrors)
        prometheus.MustRegister(getConfigOps)

        // cache update metrics
        prometheus.MustRegister(cacheUpdateErrors)
        prometheus.MustRegister(cacheUpdateFetchErrors)
        prometheus.MustRegister(cacheUpdateOps)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "net"

        "github.com/malbeclabs/doublezero/smartcontract/sdk/go/serviceability"
)

var (
        // maximum number of tunnels to provision on a given device
        maxTunnelSlots     = 64
        startUserTunnelNum = 500
)

type Device struct {
        PubKey          string
        PublicIP        net.IP
        Vpn4vLoopbackIP net.IP
        Tunnels         []*Tunnel
        TunnelSlots     int
        MgmtVrf         string
        DnsServers      []net.IP
        NtpServers      []net.IP
        Interfaces      []serviceability.Interface
}

func NewDevice(ip net.IP, publicKey string) *Device <span class="cov3" title="5">{
        tunnels := []*Tunnel{}
        for i := 0; i &lt; maxTunnelSlots; i++ </span><span class="cov10" title="320">{
                id := startUserTunnelNum + i
                tunnel := &amp;Tunnel{
                        Id:        id,
                        Allocated: false,
                }
                tunnels = append(tunnels, tunnel)
        }</span>
        <span class="cov3" title="5">return &amp;Device{
                PublicIP:    ip,
                PubKey:      publicKey,
                Tunnels:     tunnels,
                TunnelSlots: maxTunnelSlots,
        }</span>
}

func (d *Device) findTunnel(id int) *Tunnel <span class="cov3" title="6">{
        for _, tunnel := range d.Tunnels </span><span class="cov4" title="9">{
                if tunnel.Id == id </span><span class="cov3" title="6">{
                        return tunnel
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type Tunnel struct {
        Id                    int
        UnderlaySrcIP         net.IP
        UnderlayDstIP         net.IP
        OverlaySrcIP          net.IP // This needs to be derived based on the tunnel net
        OverlayDstIP          net.IP // This needs to be derived based on the tunnel net
        DzIp                  net.IP
        PubKey                string
        Allocated             bool
        IsMulticast           bool
        MulticastBoundaryList []net.IP
        MulticastSubscribers  []net.IP
        MulticastPublishers   []net.IP
}

type Vpnv4BgpPeer struct {
        PeerIP    net.IP
        PeerName  string
        SourceInt string
}

type templateData struct {
        Device                   *Device
        Vpnv4BgpPeers            []Vpnv4BgpPeer
        UnknownBgpPeers          []net.IP
        MulticastGroupBlock      string
        NoHardware               bool
        TelemetryTWAMPListenPort int
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "bytes"
        "embed"
        "fmt"
        "text/template"
)

//go:embed templates/*
var f embed.FS

func renderConfig(data templateData) (string, error) <span class="cov10" title="14">{
        t, err := template.New("tunnel.tmpl").ParseFS(f, "templates/tunnel.tmpl")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error loading tunnel template: %v", err)
        }</span>
        <span class="cov10" title="14">var output bytes.Buffer
        if err = t.Execute(&amp;output, data); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error executing template: %v", err)
        }</span>
        <span class="cov10" title="14">return output.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controller

import (
        "context"
        "fmt"
        "log/slog"
        "net"
        "net/http"
        "sort"
        "sync"
        "time"

        "github.com/gagliardetto/solana-go"
        "github.com/gagliardetto/solana-go/rpc"
        pb "github.com/malbeclabs/doublezero/controlplane/proto/controller/gen/pb-go"
        telemetryconfig "github.com/malbeclabs/doublezero/controlplane/telemetry/pkg/config"
        dzsdk "github.com/malbeclabs/doublezero/smartcontract/sdk/go"
        "github.com/malbeclabs/doublezero/smartcontract/sdk/go/serviceability"
        "github.com/mr-tron/base58"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type accountFetcher interface {
        GetProgramData(context.Context) (*serviceability.ProgramData, error)
}

type stateCache struct {
        Config          serviceability.Config
        Devices         map[string]*Device
        MulticastGroups map[string]serviceability.MulticastGroup
        Vpnv4BgpPeers   []Vpnv4BgpPeer
}

type Controller struct {
        pb.UnimplementedControllerServer

        cache stateCache
        mu    sync.RWMutex
        accountFetcher
        listener    net.Listener
        programId   string
        rpcEndpoint string
        noHardware  bool
        updateDone  chan struct{}
}

type Option func(*Controller)

func NewController(options ...Option) (*Controller, error) <span class="cov3" title="7">{
        controller := &amp;Controller{
                cache: stateCache{},
        }
        for _, o := range options </span><span class="cov5" title="17">{
                o(controller)
        }</span>
        <span class="cov3" title="7">if controller.listener == nil </span><span class="cov0" title="0">{
                lis, err := net.Listen("tcp", fmt.Sprintf("localhost:%d", 443))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to listen: %v", err)
                }</span>
                <span class="cov0" title="0">controller.listener = lis</span>
        }
        <span class="cov3" title="7">if controller.accountFetcher == nil </span><span class="cov2" title="2">{
                if controller.programId == "" </span><span class="cov1" title="1">{
                        controller.programId = serviceability.SERVICEABILITY_PROGRAM_ID_TESTNET
                }</span>
                <span class="cov2" title="2">programID, err := solana.PublicKeyFromBase58(controller.programId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid program id %s: %v", controller.programId, err)
                }</span>
                <span class="cov2" title="2">if controller.rpcEndpoint == "" </span><span class="cov1" title="1">{
                        controller.rpcEndpoint = dzsdk.DZ_LEDGER_RPC_URL
                }</span>
                <span class="cov2" title="2">client := serviceability.New(rpc.New(controller.rpcEndpoint), programID)
                controller.accountFetcher = client</span>
        }
        <span class="cov3" title="7">return controller, nil</span>
}

func WithAccountFetcher(f accountFetcher) Option <span class="cov3" title="5">{
        return func(c *Controller) </span><span class="cov3" title="5">{
                c.accountFetcher = f
        }</span>
}

func WithProgramId(programId string) Option <span class="cov1" title="1">{
        return func(c *Controller) </span><span class="cov1" title="1">{
                c.programId = programId
        }</span>
}

func WithRpcEndpoint(rpcEndpoint string) Option <span class="cov1" title="1">{
        return func(c *Controller) </span><span class="cov1" title="1">{
                c.rpcEndpoint = rpcEndpoint
        }</span>
}

// WithListener provides a way to assign a custom listener for the gRPC server.
// If no listener is passed, the controller will listen on localhost.
func WithListener(listener net.Listener) Option <span class="cov3" title="7">{
        return func(c *Controller) </span><span class="cov3" title="7">{
                c.listener = listener
        }</span>
}

// WithSignalChan provides a way to be signaled when the local state cache
// has been updated. This is used for testing.
func WithSignalChan(ch chan struct{}) Option <span class="cov2" title="3">{
        return func(c *Controller) </span><span class="cov2" title="3">{
                c.updateDone = ch
        }</span>
}

// WithNoHardware provides a way to exclude rendering config commands that will fail when not
// running on the real hardware.
func WithNoHardware() Option <span class="cov0" title="0">{
        return func(c *Controller) </span><span class="cov0" title="0">{
                c.noHardware = true
        }</span>
}

// updateStateCache fetches the latest on-chain data for devices/users and config. User accounts
// are converted into a list of tunnels, stored under their respective device, and placed in a map,
// keyed by the device's public key.
func (c *Controller) updateStateCache(ctx context.Context) error <span class="cov3" title="5">{
        data, err := c.accountFetcher.GetProgramData(ctx)
        if err != nil </span><span class="cov0" title="0">{
                cacheUpdateFetchErrors.Inc()
                return fmt.Errorf("error while loading program data: %v", err)
        }</span>

        <span class="cov3" title="5">devices := data.Devices
        if len(devices) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("0 devices found on-chain")
        }</span>
        <span class="cov3" title="5">users := data.Users
        if len(users) == 0 </span><span class="cov1" title="1">{
                slog.Debug("0 users found on-chain")
        }</span>
        <span class="cov3" title="5">cache := stateCache{
                Config:          data.Config,
                Devices:         make(map[string]*Device),
                MulticastGroups: make(map[string]serviceability.MulticastGroup),
        }

        // build cache of devices
        for _, device := range devices </span><span class="cov3" title="5">{
                ip := net.IP(device.PublicIp[:])
                if ip == nil </span><span class="cov0" title="0">{
                        // TODO: metric
                        slog.Error("invalid public ip for device", "device pubkey", device.PubKey)
                        continue</span>
                }
                <span class="cov3" title="5">devicePubKey := base58.Encode(device.PubKey[:])
                d := NewDevice(ip, devicePubKey)

                d.MgmtVrf = device.MgmtVrf
                d.Interfaces = device.Interfaces

                // Build Vpnv4BgpPeers from device interfaces
                for _, iface := range device.Interfaces </span><span class="cov3" title="4">{
                        if iface.InterfaceType == serviceability.InterfaceTypeLoopback &amp;&amp;
                                iface.LoopbackType == serviceability.LoopbackTypeVpnv4 </span><span class="cov3" title="4">{
                                // Extract IP from IpNet
                                ip := net.IP(iface.IpNet[:4])
                                d.Vpn4vLoopbackIP = ip
                                // TODO: raise an error if the IP is 0.0.0.0 (not set)
                                peer := Vpnv4BgpPeer{
                                        PeerIP:    ip,
                                        PeerName:  device.Code,
                                        SourceInt: iface.Name,
                                }
                                cache.Vpnv4BgpPeers = append(cache.Vpnv4BgpPeers, peer)
                        }</span>
                }

                <span class="cov3" title="5">if d.Vpn4vLoopbackIP == nil </span><span class="cov1" title="1">{
                        slog.Error("not adding device to cache", "device pubkey", devicePubKey, "reason", "VPNv4 loopback interface found for device")
                        continue</span>
                }

                <span class="cov3" title="4">if len(device.DnsServers) &gt; 0 </span><span class="cov1" title="1">{
                        d.DnsServers = make([]net.IP, len(device.DnsServers))
                        for i, dns := range device.DnsServers </span><span class="cov2" title="2">{
                                d.DnsServers[i] = net.IP(dns[:])
                        }</span>
                }

                <span class="cov3" title="4">if len(device.NtpServers) &gt; 0 </span><span class="cov1" title="1">{
                        d.NtpServers = make([]net.IP, len(device.NtpServers))
                        for i, ntp := range device.NtpServers </span><span class="cov2" title="2">{
                                d.NtpServers[i] = net.IP(ntp[:])
                        }</span>
                }

                <span class="cov3" title="4">cache.Devices[devicePubKey] = d</span>
        }

        // Build cache of multicast groups.
        <span class="cov3" title="5">for _, group := range data.MulticastGroups </span><span class="cov2" title="3">{
                cache.MulticastGroups[base58.Encode(group.PubKey[:])] = group
        }</span>

        // create user tunnels and add to the appropriate device
        <span class="cov3" title="5">for _, user := range users </span><span class="cov3" title="7">{
                if user.Status != serviceability.UserStatusActivated </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov3" title="7">devicePubKey := base58.Encode(user.DevicePubKey[:])
                userPubKey := base58.Encode(user.PubKey[:])

                // rules for validating on-chain user data
                validUser := func() bool </span><span class="cov3" title="7">{
                        if _, ok := cache.Devices[devicePubKey]; !ok </span><span class="cov1" title="1">{
                                // TODO: add metric
                                slog.Error("device pubkey could be found for activated user pubkey", "device pubkey", devicePubKey, "user pubkey", userPubKey)
                                return false
                        }</span>
                        <span class="cov3" title="6">if user.TunnelId == 0 </span><span class="cov0" title="0">{
                                slog.Error("tunnel id is not set for user", "user pubkey", userPubKey)
                                return false
                        }</span>
                        <span class="cov3" title="6">if user.ClientIp == [4]byte{} </span><span class="cov0" title="0">{
                                slog.Error("client ip is not set for user", "user pubkey", userPubKey)
                                return false
                        }</span>
                        <span class="cov3" title="6">if user.TunnelNet[4] != 31 </span><span class="cov0" title="0">{
                                slog.Error("tunnel network mask is not 31\n", "tunnel network mask", user.TunnelNet[4])
                                return false
                        }</span>
                        <span class="cov3" title="6">return true</span>
                }()

                <span class="cov3" title="7">if !validUser </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov3" title="6">tunnel := cache.Devices[devicePubKey].findTunnel(int(user.TunnelId))
                if tunnel == nil </span><span class="cov0" title="0">{
                        slog.Error("unable to find tunnel slot %d on device %s for user %s\n", "tunnel slot", user.TunnelId, "device pubkey", devicePubKey, "user pubkey", userPubKey)
                        continue</span>
                }
                <span class="cov3" title="6">tunnel.UnderlayDstIP = net.IP(user.ClientIp[:])
                tunnel.UnderlaySrcIP = cache.Devices[devicePubKey].PublicIP

                var overlaySrc [4]byte
                copy(overlaySrc[:], user.TunnelNet[:4])
                tunnel.OverlaySrcIP = net.IP(overlaySrc[:])

                var overlayDst [4]byte
                copy(overlayDst[:], user.TunnelNet[:4])
                tunnel.OverlayDstIP = net.IP(overlayDst[:])
                // the client is always the odd last octet; this should really be moved into the IP allocation logic
                tunnel.OverlayDstIP[3]++

                tunnel.DzIp = net.IP(user.DzIp[:])
                tunnel.PubKey = userPubKey
                tunnel.Allocated = true

                if user.UserType == serviceability.UserTypeMulticast </span><span class="cov2" title="3">{
                        tunnel.IsMulticast = true

                        boundaryList := make(map[string]struct{})

                        // Set multicast subscribers for the tunnel.
                        for _, subscriber := range user.Subscribers </span><span class="cov2" title="3">{
                                if subscriberIP, ok := cache.MulticastGroups[base58.Encode(subscriber[:])]; ok </span><span class="cov2" title="3">{
                                        tunnel.MulticastSubscribers = append(tunnel.MulticastSubscribers, net.IP(subscriberIP.MulticastIp[:]))

                                        boundaryList[net.IP(subscriberIP.MulticastIp[:]).String()] = struct{}{}
                                }</span>
                        }

                        // Set multicast publishers for the tunnel.
                        <span class="cov2" title="3">for _, publisher := range user.Publishers </span><span class="cov0" title="0">{
                                if publisherIP, ok := cache.MulticastGroups[base58.Encode(publisher[:])]; ok </span><span class="cov0" title="0">{
                                        tunnel.MulticastPublishers = append(tunnel.MulticastPublishers, net.IP(publisherIP.MulticastIp[:]))

                                        boundaryList[net.IP(publisherIP.MulticastIp[:]).String()] = struct{}{}
                                }</span>
                        }

                        // Set multicast boundary list for the tunnel.
                        // This is the combined and deduplicated list of subscribers and publishers.
                        <span class="cov2" title="3">for ip := range boundaryList </span><span class="cov2" title="3">{
                                tunnel.MulticastBoundaryList = append(tunnel.MulticastBoundaryList, net.ParseIP(ip))
                        }</span>
                        <span class="cov2" title="3">sort.Slice(tunnel.MulticastBoundaryList, func(i, j int) bool </span><span class="cov0" title="0">{
                                return tunnel.MulticastBoundaryList[i].String() &lt; tunnel.MulticastBoundaryList[j].String()
                        }</span>)
                }
        }

        // swap out state cache with new version
        <span class="cov3" title="5">slog.Debug("updating state cache", "state cache", cache)
        c.swapCache(cache)
        return nil</span>
}

// swapCache atomically updates the local state cache with the latest copy and
// if a signal channel is present, sends a notification.
func (c *Controller) swapCache(cache stateCache) <span class="cov4" title="10">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.cache = cache
        if c.updateDone != nil </span><span class="cov2" title="3">{
                c.updateDone &lt;- struct{}{}
        }</span>
}

// Run starts a goroutine for updating the local state cache with on-chain
// data and another for a gRPC server to service devices.
func (c *Controller) Run(ctx context.Context) error <span class="cov2" title="3">{
        // start prometheus
        go func() </span><span class="cov2" title="3">{
                mux := http.NewServeMux()
                mux.Handle("/metrics", promhttp.Handler())
                http.ListenAndServe("127.0.0.1:2112", mux) //nolint
        }</span>()

        // start on-chain fetcher
        <span class="cov2" title="3">go func() </span><span class="cov2" title="3">{
                slog.Info("starting fetch of on-chain data", "program-id", c.programId, "rpc-endpoint", c.rpcEndpoint)
                if err := c.updateStateCache(ctx); err != nil </span><span class="cov0" title="0">{
                        cacheUpdateErrors.Inc()
                        slog.Error("error fetching accounts", "error", err)
                }</span>
                <span class="cov2" title="3">cacheUpdateOps.Inc()
                ticker := time.NewTicker(10 * time.Second)
                for </span><span class="cov2" title="3">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov2" title="3">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                slog.Debug("updating state cache on clock tick")
                                if err := c.updateStateCache(ctx); err != nil </span><span class="cov0" title="0">{
                                        cacheUpdateErrors.Inc()
                                        slog.Error("error fetching accounts", "error", err)
                                }</span>
                                <span class="cov0" title="0">cacheUpdateOps.Inc()</span>
                        }
                }
        }()

        // start gRPC server
        <span class="cov2" title="3">server := grpc.NewServer()
        pb.RegisterControllerServer(server, c)

        errChan := make(chan error)
        go func() </span><span class="cov2" title="3">{
                if err := server.Serve(c.listener); err != nil </span><span class="cov0" title="0">{
                        errChan &lt;- err
                }</span>
        }()

        <span class="cov2" title="3">select </span>{
        case &lt;-ctx.Done():<span class="cov2" title="3">
                server.GracefulStop()
                return nil</span>
        case err := &lt;-errChan:<span class="cov0" title="0">
                return err</span>
        }

}

// GetConfig renders the latest device configuration based on cached device data
func (c *Controller) GetConfig(ctx context.Context, req *pb.ConfigRequest) (*pb.ConfigResponse, error) <span class="cov4" title="8">{
        getConfigOps.WithLabelValues(req.GetPubkey()).Inc()
        c.mu.RLock()
        defer c.mu.RUnlock()
        device, ok := c.cache.Devices[req.GetPubkey()]
        if !ok </span><span class="cov0" title="0">{
                getConfigPubkeyErrors.WithLabelValues(req.GetPubkey()).Inc()
                err := status.Errorf(codes.NotFound, "pubkey %s not found", req.Pubkey)
                return nil, err
        }</span>

        // compare peers from device to on-chain
        <span class="cov4" title="8">peerFound := func(peer net.IP) bool </span><span class="cov4" title="8">{
                for _, tun := range device.Tunnels </span><span class="cov10" title="450">{
                        if tun.OverlayDstIP.Equal(peer) </span><span class="cov1" title="1">{
                                return true
                        }</span>
                }
                <span class="cov3" title="7">return false</span>
        }

        <span class="cov4" title="8">unknownPeers := []net.IP{}
        for _, peer := range req.GetBgpPeers() </span><span class="cov4" title="8">{
                ip := net.ParseIP(peer)
                if ip == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov4" title="8">if peerFound(ip) </span><span class="cov1" title="1">{
                        continue</span>
                }
                // Only remove peers with addresses that DZ has assigned. This will avoid removal of contributor-configured peers like DIA.
                <span class="cov3" title="7">if isIPInBlock(ip, c.cache.Config.UserTunnelBlock) || isIPInBlock(ip, c.cache.Config.TunnelTunnelBlock) </span><span class="cov2" title="3">{
                        unknownPeers = append(unknownPeers, ip)
                }</span>
        }

        <span class="cov4" title="8">if len(unknownPeers) != 0 </span><span class="cov2" title="2">{
                slog.Error("device returned unknown peers", "device pubkey", req.GetPubkey(), "number of unknown peers", len(unknownPeers), "peers", unknownPeers)
        }</span>

        <span class="cov4" title="8">multicastGroupBlock := formatCIDR(&amp;c.cache.Config.MulticastGroupBlock)

        data := templateData{
                MulticastGroupBlock:      multicastGroupBlock,
                Device:                   device,
                Vpnv4BgpPeers:            c.cache.Vpnv4BgpPeers,
                UnknownBgpPeers:          unknownPeers,
                NoHardware:               c.noHardware,
                TelemetryTWAMPListenPort: telemetryconfig.TWAMPListenPort,
        }

        config, err := renderConfig(data)
        if err != nil </span><span class="cov0" title="0">{
                getConfigRenderErrors.WithLabelValues(req.GetPubkey()).Inc()
                err := status.Errorf(codes.Aborted, "config rendering for pubkey %s failed: %v", req.Pubkey, err)
                return nil, err
        }</span>
        <span class="cov4" title="8">return &amp;pb.ConfigResponse{Config: config}, nil</span>
}

// formatCIDR formats a 5-byte network block into CIDR notation
func formatCIDR(b *[5]byte) string <span class="cov4" title="8">{
        ip := net.IPv4(b[0], b[1], b[2], b[3])
        mask := net.CIDRMask(int(b[4]), 32)
        return (&amp;net.IPNet{IP: ip, Mask: mask}).String()
}</span>

// isIPInBlock checks if an IP address is within a 5-byte network block
func isIPInBlock(ip net.IP, block [5]uint8) bool <span class="cov4" title="12">{
        network := net.IPv4(block[0], block[1], block[2], block[3])
        mask := net.CIDRMask(int(block[4]), 32)
        ipNet := &amp;net.IPNet{IP: network, Mask: mask}
        return ipNet.Contains(ip)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
